<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>K-Nearest Neighbors: Classification vs Regression</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <style>
   body {
      font-family: 'Roboto', Arial, sans-serif;
      margin: 0;
      background: #17191a;
      min-height: 100vh;
      color: #ff79c6;
      padding: 20px;
    }
    section {
      margin-bottom: 55px;
      background: #222025;
      border-radius: 18px;
      box-shadow: 0 4px 30px rgba(255,121,198,.09);
      padding: 36px 32px 22px 32px;
      border-left: 7px solid #ff79c6;
      position: relative;
      max-width: 1100px;
      margin-left: auto;
      margin-right: auto;
    }
    h1 { color:#ffb3de; margin:0 0 8px 0; }
    h2 { margin: 0 0 10px 0; color: #ffb3de; font-weight: 700; }
    section h3 {
      font-size: 1.18em; color: #ffb3de; margin-bottom: 5px; margin-top: 25px;
      font-weight: 600; border-bottom: 1px solid #ffb3de; padding-bottom: 2px;
    }
    p { color:#ffd7f0; line-height: 1.6; }
    pre {
      background: #19121a; color: #ffb3de; padding: 15px 18px; border-radius: 8px;
      font-size: 1.02em; line-height: 1.7; overflow-x: auto;
      box-shadow: 0 2px 10px rgba(255,121,198,0.11);
      white-space: pre;
    }
    .pill {
      display:inline-block; background:#19121a; border:1px solid #ff79c6;
      border-radius:999px; padding:6px 14px; margin:2px 8px 2px 0; font-size:.95em;
    }
    .note { color:#ffd7f0; opacity:.9; font-size: 0.95em; margin-top: 10px; }
    ul { margin-top: 8px; color:#ffd7f0; line-height: 1.8; }
    code.inline { background:#19121a; padding:2px 6px; border-radius:6px; color: #ffb3de; }
    .legend { display:flex; gap:14px; align-items:center; margin:12px 0 18px; flex-wrap: wrap;}
    .swatch { width:16px; height:16px; border-radius:50%; display:inline-block; border:1px solid #00000033; }
    .swatch.blue { background:#5fb3ff; }
    .swatch.red { background:#ff5f5f; }
    .swatch.green { background:#5fbf5f; }
    .swatch.line { background:#ffd84d; height: 3px; width: 30px; border-radius: 2px; }
    .svgwrap{ background:#1a151c; border-radius:12px; padding:15px; box-shadow: inset 0 0 0 1px rgba(255,121,198,0.2); margin-top: 15px;}
    canvas { width:100%; height:auto; display:block; }
    .split-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-top: 20px;
    }
    .comparison-box {
      background: #19121a;
      border: 2px solid #ff79c6;
      border-radius: 12px;
      padding: 20px;
    }
    .comparison-box h3 {
      margin-top: 0;
      color: #ffb3de;
      border: none;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #3a2f36;
    }
    th {
      background: #19121a;
      color: #ffb3de;
      font-weight: 700;
    }
    td {
      color: #ffd7f0;
    }
    .highlight {
      background: #19121a;
      padding: 2px 6px;
      border-radius: 4px;
      color: #5fbf5f;
    }
    @media (max-width: 768px) {
      .split-container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>

<section id="top">
  <center>
    <h1>
      <span class="pill"><i class="fas fa-network-wired"></i> K-Nearest Neighbors (KNN)</span>
    </h1>
    <h2 style="margin-top: 15px;">Classification vs Regression</h2>
  </center>

  <p style="text-align: center; font-size: 1.1em; margin-top: 20px;">
    KNN is a <strong>versatile algorithm</strong> that works for both classification and regression tasks.
    The only difference is <strong>how the neighbors vote</strong>!
  </p>
</section>

<section id="comparison">
  <h2>The Core Concept</h2>
  <p>
    K-Nearest Neighbors finds the <strong>k closest data points</strong> to a new query point, then makes a prediction based on those neighbors.
  </p>

  <div class="split-container">
    <div class="comparison-box">
      <h3><i class="fas fa-tag"></i> Classification</h3>
      <p><strong>Task:</strong> Predict a <span class="highlight">class label</span> (category)</p>
      <p><strong>Method:</strong> <span class="highlight">Majority vote</span> among k neighbors</p>
      <p><strong>Output:</strong> Discrete class (e.g., "Benign" or "Malignant")</p>
      
      <h3 style="margin-top: 25px;">Import Statement</h3>
      <pre>from sklearn.neighbors import KNeighborsClassifier</pre>
      
      <h3>Example Code</h3>
      <pre>knn_clf = KNeighborsClassifier(n_neighbors=5)
knn_clf.fit(X_train, y_train)
predictions = knn_clf.predict(X_test)
# Output: ['Benign', 'Malignant', 'Benign', ...]</pre>
    </div>

    <div class="comparison-box">
      <h3><i class="fas fa-chart-line"></i> Regression</h3>
      <p><strong>Task:</strong> Predict a <span class="highlight">continuous value</span></p>
      <p><strong>Method:</strong> <span class="highlight">Average</span> of k neighbors' values</p>
      <p><strong>Output:</strong> Continuous number (e.g., house price $250,000)</p>
      
      <h3 style="margin-top: 25px;">Import Statement</h3>
      <pre>from sklearn.neighbors import KNeighborsRegressor</pre>
      
      <h3>Example Code</h3>
      <pre>knn_reg = KNeighborsRegressor(n_neighbors=5)
knn_reg.fit(X_train, y_train)
predictions = knn_reg.predict(X_test)
# Output: [250000, 180000, 320000, ...]</pre>
    </div>
  </div>
</section>

  
<section id="comparison-table">
  <h2>Side-by-Side Comparison</h2>
  
  <table>
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Classification</th>
        <th>Regression</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Class Name</strong></td>
        <td><code class="inline">KNeighborsClassifier</code></td>
        <td><code class="inline">KNeighborsRegressor</code></td>
      </tr>
      <tr>
        <td><strong>Import From</strong></td>
        <td><code class="inline">sklearn.neighbors</code></td>
        <td><code class="inline">sklearn.neighbors</code></td>
      </tr>
      <tr>
        <td><strong>Output Type</strong></td>
        <td>Discrete classes (labels)</td>
        <td>Continuous numbers</td>
      </tr>
      <tr>
        <td><strong>Aggregation Method</strong></td>
        <td>Majority vote</td>
        <td>Mean (or weighted mean)</td>
      </tr>
      <tr>
        <td><strong>Example Output</strong></td>
        <td>"Benign", "Malignant", "Benign"</td>
        <td>250000, 180000, 320000</td>
      </tr>
      <tr>
        <td><strong>Evaluation Metrics</strong></td>
        <td>Accuracy, Precision, Recall, F1</td>
        <td>R², RMSE, MSE, MAE</td>
      </tr>
      <tr>
        <td><strong>Common Use Cases</strong></td>
        <td>Spam detection, disease diagnosis, image classification</td>
        <td>House price prediction, stock forecasting, temperature prediction</td>
      </tr>
    </tbody>
  </table>
</section>

<section id="code-examples">
  <h2>Complete Code Examples</h2>
  
  <h3>Classification Example (Breast Cancer)</h3>
  <pre>from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.model_selection import GridSearchCV
import numpy as np

# Create pipeline with scaling
knn_clf_pipe = Pipeline([
    ("scaler", StandardScaler()),
    ("knn", KNeighborsClassifier())
])

# Tune hyperparameters
knn_clf_grid = {
    "knn__n_neighbors": np.arange(1, 31, 2),
    "knn__weights": ["uniform", "distance"],
    "knn__metric": ["euclidean", "manhattan"]
}

knn_clf = GridSearchCV(knn_clf_pipe, knn_clf_grid, cv=5, scoring="accuracy")
knn_clf.fit(X_train, y_train)

# Predict classes
predictions = knn_clf.predict(X_test)
print(predictions)  # ['Benign', 'Malignant', 'Benign', ...]</pre>

  <h3>Regression Example (House Prices)</h3>
  <pre>from sklearn.neighbors import KNeighborsRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.model_selection import GridSearchCV
import numpy as np

# Create pipeline with scaling
knn_reg_pipe = Pipeline([
    ("scaler", StandardScaler()),
    ("knn", KNeighborsRegressor())
])

# Tune hyperparameters
knn_reg_grid = {
    "knn__n_neighbors": np.arange(1, 31, 2),
    "knn__weights": ["uniform", "distance"],  # Distance often better for regression
    "knn__metric": ["euclidean", "manhattan"]
}

knn_reg = GridSearchCV(knn_reg_pipe, knn_reg_grid, cv=5, scoring="r2")
knn_reg.fit(X_train, y_train)

# Predict continuous values
predictions = knn_reg.predict(X_test)
print(predictions)  # [250000, 180000, 320000, ...]</pre>
</section>

<section id="key-points">
  <h2>Key Takeaways</h2>
  <ul>
    <li><strong>Same algorithm, different aggregation:</strong> Both use k-nearest neighbors, but classification uses voting and regression uses averaging.</li>
    <li><strong>Same hyperparameters:</strong> Both use <code class="inline">n_neighbors</code>, <code class="inline">weights</code>, <code class="inline">metric</code>, etc.</li>
    <li><strong>Same preprocessing needs:</strong> Both require feature scaling (eg: StandardScaler).</li>
    <li><strong>Both in sklearn.neighbors:</strong> Part of the same module because they share the same nearest-neighbor search infrastructure.</li>
    <li><strong>Weights matter more in regression:</strong> <code class="inline">weights='distance'</code> often significantly improves regression performance.</li>
    <li><strong>Different evaluation metrics:</strong> Use accuracy/F1 for classification, R²/RMSE for regression.</li>
  </ul>
</section>

<script>
  // ========== CLASSIFICATION CANVAS ==========
  const classCanvas = document.getElementById('classCanvas');
  const classCtx = classCanvas.getContext('2d');
  const CW = classCanvas.width, CH = classCanvas.height;
  const CPAD = 60;

  // Generate random points for two classes
  function generateClassData() {
    const bluePoints = [];
    const redPoints = [];
    
    // Class A (blue) - cluster around (2, 3)
    for (let i = 0; i < 15; i++) {
      bluePoints.push([
        2 + (Math.random() - 0.5) * 3,
        3 + (Math.random() - 0.5) * 3
      ]);
    }
    
    // Class B (red) - cluster around (6, 5)
    for (let i = 0; i < 15; i++) {
      redPoints.push([
        6 + (Math.random() - 0.5) * 3,
        5 + (Math.random() - 0.5) * 3
      ]);
    }
    
    return { bluePoints, redPoints };
  }

  const { bluePoints, redPoints } = generateClassData();
  const queryPoint = [4, 4]; // New point to classify

  // Find k nearest neighbors
  function findNearest(query, allPoints, k) {
    const distances = allPoints.map((p, idx) => ({
      point: p.point,
      color: p.color,
      dist: Math.sqrt((p.point[0] - query[0])**2 + (p.point[1] - query[1])**2)
    }));
    distances.sort((a, b) => a.dist - b.dist);
    return distances.slice(0, k);
  }

  const allClassPoints = [
    ...bluePoints.map(p => ({ point: p, color: 'blue' })),
    ...redPoints.map(p => ({ point: p, color: 'red' }))
  ];
  const k = 5;
  const neighbors = findNearest(queryPoint, allClassPoints, k);

  // Coordinate mapping
  const cx2px = x => CPAD + (x / 9) * (CW - 2 * CPAD);
  const cy2px = y => CH - CPAD - (y / 8) * (CH - 2 * CPAD);

  function drawClassAxes() {
    classCtx.strokeStyle = "#3a2f36"; classCtx.lineWidth = 1;
    classCtx.beginPath(); classCtx.moveTo(CPAD, CH-CPAD); classCtx.lineTo(CW-CPAD, CH-CPAD); classCtx.stroke();
    classCtx.beginPath(); classCtx.moveTo(CPAD, CPAD); classCtx.lineTo(CPAD, CH-CPAD); classCtx.stroke();
    
    classCtx.fillStyle = "#ffb3de"; classCtx.font = "14px Roboto, Arial";
    classCtx.fillText("Feature 1", CW-CPAD+10, CH-CPAD+5);
    classCtx.fillText("Feature 2", CPAD-12, CPAD-10);
  }

  function drawClassPoint(point, color, size = 6) {
    const px = cx2px(point[0]);
    const py = cy2px(point[1]);
    
    classCtx.fillStyle = color;
    classCtx.strokeStyle = "#00000055";
    classCtx.lineWidth = 1;
    classCtx.beginPath();
    classCtx.arc(px, py, size, 0, Math.PI * 2);
    classCtx.fill();
    classCtx.stroke();
  }

  function drawClassification() {
    classCtx.clearRect(0, 0, CW, CH);
    drawClassAxes();
    
    // Draw all points
    bluePoints.forEach(p => drawClassPoint(p, '#5fb3ff'));
    redPoints.forEach(p => drawClassPoint(p, '#ff5f5f'));
    
    // Draw connections to neighbors
    classCtx.strokeStyle = '#ffd84d';
    classCtx.lineWidth = 1;
    classCtx.setLineDash([5, 5]);
    neighbors.forEach(n => {
      classCtx.beginPath();
      classCtx.moveTo(cx2px(queryPoint[0]), cy2px(queryPoint[1]));
      classCtx.lineTo(cx2px(n.point[0]), cy2px(n.point[1]));
      classCtx.stroke();
    });
    classCtx.setLineDash([]);
    
    // Highlight nearest neighbors
    neighbors.forEach(n => {
      const color = n.color === 'blue' ? '#5fb3ff' : '#ff5f5f';
      const px = cx2px(n.point[0]);
      const py = cy2px(n.point[1]);
      
      classCtx.strokeStyle = '#ffd84d';
      classCtx.lineWidth = 3;
      classCtx.beginPath();
      classCtx.arc(px, py, 9, 0, Math.PI * 2);
      classCtx.stroke();
    });
    
    // Draw query point (star)
    const qx = cx2px(queryPoint[0]);
    const qy = cy2px(queryPoint[1]);
    
    classCtx.fillStyle = '#ffd84d';
    classCtx.strokeStyle = '#000';
    classCtx.lineWidth = 2;
    classCtx.font = 'bold 24px Arial';
    classCtx.fillText('⭐', qx - 12, qy + 8);
    
    // Count votes
    const blueVotes = neighbors.filter(n => n.color === 'blue').length;
    const redVotes = neighbors.filter(n => n.color === 'red').length;
    
    // Draw vote count
    classCtx.fillStyle = '#ffb3de';
    classCtx.font = 'bold 16px Roboto, Arial';
    classCtx.fillText(`k = 5 neighbors:`, qx + 25, qy - 30);
    classCtx.fillStyle = '#5fb3ff';
    classCtx.fillText(`Class A: ${blueVotes} votes`, qx + 25, qy - 10);
    classCtx.fillStyle = '#ff5f5f';
    classCtx.fillText(`Class B: ${redVotes} votes`, qx + 25, qy + 10);
    classCtx.fillStyle = '#5fbf5f';
    classCtx.fillText(`→ Prediction: Class A`, qx + 25, qy + 35);
  }

  drawClassification();

  // ========== REGRESSION CANVAS ==========
  const regCanvas = document.getElementById('regCanvas');
  const regCtx = regCanvas.getContext('2d');
  const RW = regCanvas.width, RH = regCanvas.height;
  const RPAD = 60;

  // Generate regression data
  function generateRegData() {
    const points = [];
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * 8 + 1;
      const y = 2 + 0.5 * x + (Math.random() - 0.5) * 1.5;
      points.push([x, y]);
    }
    return points;
  }

  const regPoints = generateRegData();
  const regQuery = [5, 0]; // x value only, y to be predicted
  
  // Find nearest for regression
  const regNeighbors = regPoints
    .map(p => ({ point: p, dist: Math.abs(p[0] - regQuery[0]) }))
    .sort((a, b) => a.dist - b.dist)
    .slice(0, k);
  
  const avgY = regNeighbors.reduce((sum, n) => sum + n.point[1], 0) / k;
  const regQueryFull = [regQuery[0], avgY];

  // Coordinate mapping
  const rx2px = x => RPAD + (x / 10) * (RW - 2 * RPAD);
  const ry2px = y => RH - RPAD - (y / 8) * (RH - 2 * RPAD);

  function drawRegAxes() {
    regCtx.strokeStyle = "#3a2f36"; regCtx.lineWidth = 1;
    regCtx.beginPath(); regCtx.moveTo(RPAD, RH-RPAD); regCtx.lineTo(RW-RPAD, RH-RPAD); regCtx.stroke();
    regCtx.beginPath(); regCtx.moveTo(RPAD, RPAD); regCtx.lineTo(RPAD, RH-RPAD); regCtx.stroke();
    
    regCtx.fillStyle = "#ffb3de"; regCtx.font = "14px Roboto, Arial";
    regCtx.fillText("X (Feature)", RW-RPAD-50, RH-RPAD+25);
    regCtx.fillText("y (Target)", RPAD-50, RPAD-10);
  }

  function drawRegPoint(point, color, size = 6) {
    const px = rx2px(point[0]);
    const py = ry2px(point[1]);
    
    regCtx.fillStyle = color;
    regCtx.strokeStyle = "#00000055";
    regCtx.lineWidth = 1;
    regCtx.beginPath();
    regCtx.arc(px, py, size, 0, Math.PI * 2);
    regCtx.fill();
    regCtx.stroke();
  }

  function drawRegression() {
    regCtx.clearRect(0, 0, RW, RH);
    drawRegAxes();
    
    // Draw all training points
    regPoints.forEach(p => drawRegPoint(p, '#5fbf5f'));
    
    // Draw vertical line at query x
    const qx = rx2px(regQuery[0]);
    regCtx.strokeStyle = '#ffd84d';
    regCtx.lineWidth = 2;
    regCtx.setLineDash([5, 5]);
    regCtx.beginPath();
    regCtx.moveTo(qx, RPAD);
    regCtx.lineTo(qx, RH - RPAD);
    regCtx.stroke();
    regCtx.setLineDash([]);
    
    // Highlight nearest neighbors
    regNeighbors.forEach(n => {
      const px = rx2px(n.point[0]);
      const py = ry2px(n.point[1]);
      
      regCtx.strokeStyle = '#ffd84d';
      regCtx.lineWidth = 3;
      regCtx.beginPath();
      regCtx.arc(px, py, 9, 0, Math.PI * 2);
      regCtx.stroke();
      
      // Draw connection line
      regCtx.strokeStyle = '#ffd84d';
      regCtx.lineWidth = 1;
      regCtx.setLineDash([3, 3]);
      regCtx.beginPath();
      regCtx.moveTo(px, py);
      regCtx.lineTo(qx, ry2px(avgY));
      regCtx.stroke();
      regCtx.setLineDash([]);
    });
    
    // Draw predicted point
    const py = ry2px(avgY);
    regCtx.fillStyle = '#ffd84d';
    regCtx.strokeStyle = '#000';
    regCtx.lineWidth = 2;
    regCtx.font = 'bold 24px Arial';
    regCtx.fillText('⭐', qx - 12, py + 8);
    
    // Draw prediction info
    regCtx.fillStyle = '#ffb3de';
    regCtx.font = 'bold 16px Roboto, Arial';
    regCtx.fillText(`k = 5 neighbors`, qx + 25, py - 40);
    regCtx.fillText(`Average y-value:`, qx + 25, py - 20);
    regCtx.fillStyle = '#5fbf5f';
    regNeighbors.forEach((n, i) => {
      regCtx.fillText(`${n.point[1].toFixed(2)}${i < k-1 ? ',' : ''}`, qx + 25 + i * 40, py);
    });
    regCtx.fillStyle = '#ffd84d';
    regCtx.fillText(`→ Prediction: ${avgY.toFixed(2)}`, qx + 25, py + 25);
  }

  drawRegression();
</script>

</body>
</html>
