<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Linear Regression (−10…10)</title>
  <style>
    body{margin:0;background:#1a1d1f;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;color:#ffb3de}
    .container{max-width:1000px;margin:28px auto;padding:0 16px}
    h3{color:#ff79c6}
    /* Card */
    #linreg-demo.linreg-card{
      background:#222025;border-radius:18px;padding:22px 22px 16px 22px;
      border-left:7px solid #ff79c6; box-shadow:0 4px 30px rgba(255,121,198,.09);
    }
    #linreg-demo .linreg-toolbar{display:flex;gap:10px;align-items:center;margin:12px 0 10px 0;flex-wrap:wrap}
    #linreg-demo button{
      background:#ff79c6;border:none;color:#1a1d1f;padding:8px 12px;border-radius:10px;
      font-weight:700;cursor:pointer;box-shadow:0 3px 12px rgba(255,121,198,.35)
    }
    #linreg-demo button:hover{ filter:brightness(1.05) }
    #linreg-demo .linreg-toggle{ display:inline-flex;gap:8px;align-items:center; color:#ffb3de }
    #linreg-demo .linreg-stats{ display:flex;gap:18px;flex-wrap:wrap;margin:8px 0 14px 0; color:#ffb3de;font-weight:600 }
    #linreg-demo .linreg-note{ color:#ffb3de;margin-top:10px }
    #linreg-demo .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace }

    /* SVG styles */
    #lr-svg .axis path, #lr-svg .axis line{ stroke:#6a5060 }
    #lr-svg .axis text{ fill:#ffb3de;font-size:12px }
    #lr-svg .point{ fill:#ff79c6; cursor:grab }
    #lr-svg .point:active{ cursor:grabbing }
    #lr-svg .fit-line{ stroke:#fff52e; stroke-width:3 }
    #lr-svg .residual{ stroke:#7fd7ff; stroke-dasharray:4 4; opacity:.9 }
    #lr-svg .grid line{ stroke:#2f2630 }
    #lr-svg .zero-axis{ stroke:#9a7888; stroke-width:1.5 }
    #lr-svg .tooltip{ pointer-events:none; font-size:12px; fill:#111 }
  </style>
</head>
<body>
  <div class="container">
    <section id="linreg-demo" class="linreg-card">
      <h3 style="margin-top:0;">Interactive: Linear Regression (Drag the points!)</h3>
      <div class="linreg-toolbar">
        <button id="lr-reset">Reset</button>
        <button id="lr-add">Add point</button>
        <label class="linreg-toggle">
          <input type="checkbox" id="lr-show-residuals" />
          Show residuals
        </label>
      </div>

      <div class="linreg-stats">
        <span id="lr-equation" class="mono">y = a x + b</span>
        <span id="lr-r2" class="mono">R² = —</span>
      </div>

      <svg id="lr-svg" viewBox="0 0 760 520" width="100%" style="max-width:900px; display:block; background:#151218; border-radius:14px; box-shadow:0 6px 22px rgba(255,121,198,.08)"></svg>

      <p class="linreg-note">
        <b>Tip:</b> Drag the magenta points. The least-squares line, equation, and R² update instantly.
        Toggle residuals to see vertical errors from each point to the line.
      </p>
    </section>
  </div>

  <script>
  (function(){
    // ====== Config: negative & positive axes ======
    const svg = document.getElementById('lr-svg');
    const W = 760, H = 520, PAD = 60;
    const innerW = W - PAD*2, innerH = H - PAD*2;

    // Axes −10..10
    const XMIN=-10, XMAX=10, YMIN=-10, YMAX=10;

    // Scales
    const x2px = x => PAD + (x - XMIN) / (XMAX - XMIN) * innerW;
    const y2px = y => H - PAD - (y - YMIN) / (YMAX - YMIN) * innerH;
    const px2x = px => XMIN + (px - PAD) / innerW * (XMAX - XMIN);
    const px2y = py => YMIN + (H - PAD - py) / innerH * (YMAX - YMIN);

    // SVG groups
    const svgns = "http://www.w3.org/2000/svg";
    const gGrid = mk('g'), gAxes = mk('g'), gResiduals = mk('g'), gLine = mk('g'), gPoints = mk('g');
    svg.append(gGrid, gAxes, gResiduals, gLine, gPoints);

    // Grid & axes
    drawGrid();
    drawAxes();

    // Data
    let pts = [];
    function seedData(){
      pts = [];
      const a=0.7, b=1.3;
      for(let i=0;i<12;i++){
        const x = rnd(-9,9);
        const y = a*x + b + rnd(-2.0, 2.0);
        pts.push({x,y});
      }
    }
    seedData();

    // UI
    const showResidualsCheckbox = document.getElementById('lr-show-residuals');
    const eqEl = document.getElementById('lr-equation');
    const r2El = document.getElementById('lr-r2');
    document.getElementById('lr-reset').addEventListener('click', ()=>{ seedData(); render(); });
    document.getElementById('lr-add').addEventListener('click', ()=>{ pts.push({x:rnd(XMIN, XMAX), y:rnd(YMIN, YMAX)}); render(); });
    showResidualsCheckbox.addEventListener('change', render);

    // Tooltip (optional)
    const tip = mk('text', {class:'tooltip', x: 8, y: 18});
    const tipBg = mk('rect', {fill:'#ffb3de', rx:6, ry:6, x:4, y:4, width:0, height:0, opacity:0.9});
    tip.textContent = '';
    svg.append(tipBg, tip);
    hideTip();

    // Drag handling: single listener
    let draggingIndex = null;
    svg.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', ()=>{ draggingIndex=null; hideTip(); });

    function onMouseMove(e){
      if(draggingIndex===null) return;
      const pt = getMousePos(svg, e);
      const nx = clamp(px2x(pt.x), XMIN, XMAX);
      const ny = clamp(px2y(pt.y), YMIN, YMAX);
      pts[draggingIndex] = {x:nx, y:ny};
      render();
      showTip(`(${fmt(nx,2)}, ${fmt(ny,2)})`);
    }

    // Render
    function render(){
      const {a, b, r2} = fitLine(pts);

      eqEl.textContent = `y = ${fmt(a)} x + ${fmt(b)}`;
      r2El.textContent = `R² = ${fmt(r2,3)}`;

      // Residuals
      gResiduals.innerHTML = '';
      if(showResidualsCheckbox.checked){
        pts.forEach(p=>{
          const yhat = a*p.x + b;
          gResiduals.append(mk('line', {
            class:'residual',
            x1:x2px(p.x), y1:y2px(p.y),
            x2:x2px(p.x), y2:y2px(yhat)
          }));
        });
      }

      // Fit line
      gLine.innerHTML = '';
      gLine.append(mk('line', {
        class:'fit-line',
        x1:x2px(XMIN), y1:y2px(a*XMIN + b),
        x2:x2px(XMAX), y2:y2px(a*XMAX + b)
      }));

      // Points
      gPoints.innerHTML = '';
      pts.forEach((p,i)=>{
        const c = mk('circle', {class:'point', r:6, cx:x2px(p.x), cy:y2px(p.y)});
        c.addEventListener('mousedown', ()=>{ draggingIndex=i; c.style.filter='brightness(1.2)'; });
        c.addEventListener('mouseup', ()=>{ c.style.filter=''; });
        c.addEventListener('mouseenter', ()=> showTip(`(${fmt(p.x,2)}, ${fmt(p.y,2)})`) );
        c.addEventListener('mouseleave', ()=> hideTip() );
        gPoints.append(c);
      });
    }

    // ====== Math: OLS fit ======
    function fitLine(data){
      const n = data.length || 1;
      let sx=0, sy=0, sxx=0, syy=0, sxy=0;
      for(const {x,y} of data){ sx+=x; sy+=y; sxx+=x*x; syy+=y*y; sxy+=x*y; }
      const xbar = sx/n, ybar = sy/n;
      const varx = sxx - n*xbar*xbar;
      const covxy = sxy - n*xbar*ybar;
      const a = (varx === 0) ? 0 : (covxy / varx);
      const b = ybar - a*xbar;
      let ss_res = 0, ss_tot = 0;
      for(const {x,y} of data){ const yhat = a*x + b; ss_res += (y - yhat) ** 2; ss_tot += (y - ybar) ** 2; }
      const r2 = (ss_tot === 0) ? 1 : (1 - ss_res/ss_tot);
      return {a, b, r2};
    }

    // ====== Axes & grid (−10 … 10) ======
    function drawGrid(){
      const g = mk('g', {class:'grid'});
      // minor grid every 1
      for(let x=Math.ceil(XMIN); x<=XMAX; x++){
        g.append(mk('line', {x1:x2px(x), y1:y2px(YMIN), x2:x2px(x), y2:y2px(YMAX)}));
      }
      for(let y=Math.ceil(YMIN); y<=YMAX; y++){
        g.append(mk('line', {x1:x2px(XMIN), y1:y2px(y), x2:x2px(XMAX), y2:y2px(y)}));
      }
      svg.append(g);
    }

    function drawAxes(){
      const g = mk('g', {class:'axis'});
      // axes through 0
      g.append(mk('line', {class:'zero-axis', x1:x2px(XMIN), y1:y2px(0), x2:x2px(XMAX), y2:y2px(0)}));
      g.append(mk('line', {class:'zero-axis', x1:x2px(0), y1:y2px(YMIN), x2:x2px(0), y2:y2px(YMAX)}));

      // ticks & labels every 2
      const step = 2;
      for(let x=Math.ceil(XMIN/step)*step; x<=XMAX; x+=step){
        const px = x2px(x);
        g.append(mk('line', {x1:px, y1:y2px(0)-4, x2:px, y2:y2px(0)+4}));
        const t = mk('text', {x:px, y:y2px(0)+18, 'text-anchor':'middle'}); t.textContent = x; g.append(t);
      }
      for(let y=Math.ceil(YMIN/step)*step; y<=YMAX; y+=step){
        const py = y2px(y);
        g.append(mk('line', {x1:x2px(0)-4, y1:py, x2:x2px(0)+4, y2:py}));
        const t = mk('text', {x:x2px(0)-12, y:py+4, 'text-anchor':'end'}); t.textContent = y; g.append(t);
      }

      // axis labels
      const xl = mk('text', {x: PAD+innerW/2, y: y2px(0)+40, 'text-anchor':'middle'}); xl.textContent = 'x';
      const yl = mk('text', {x: x2px(0)-35, y: PAD+innerH/2, 'text-anchor':'middle', transform:`rotate(-90 ${x2px(0)-35} ${PAD+innerH/2})`}); yl.textContent = 'y';
      svg.append(g, xl, yl);
    }

    // ====== Helpers ======
    function mk(tag, attrs={}){ const el = document.createElementNS(svgns, tag); for(const [k,v] of Object.entries(attrs)) el.setAttribute(k,v); return el; }
    function rnd(a,b){ return a + Math.random()*(b-a); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function getMousePos(svgEl, evt){ const pt = svgEl.createSVGPoint(); pt.x = evt.clientX; pt.y = evt.clientY; const ctm = svgEl.getScreenCTM().inverse(); return pt.matrixTransform(ctm); }
    function fmt(num, d=2){ if(!isFinite(num)) return '—'; const s = (+num).toFixed(d); return s.replace(/\.?0+$/,''); }
    function showTip(text){ tip.textContent = text; const bb = tip.getBBox(); tipBg.setAttribute('width', bb.width + 12); tipBg.setAttribute('height', bb.height + 10); }
    function hideTip(){ tip.textContent=''; tipBg.setAttribute('width', 0); tipBg.setAttribute('height', 0); }

    // Initial render
    render();
  })();
  </script>
</body>
</html>
