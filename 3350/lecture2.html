<section id="linreg-demo" class="linreg-card">
  <h3 style="margin-top:0;">Interactive: Linear Regression (Drag the points!)</h3>
  <div class="linreg-toolbar">
    <button id="lr-reset">Reset</button>
    <button id="lr-add">Add point</button>
    <label class="linreg-toggle">
      <input type="checkbox" id="lr-show-residuals" />
      Show residuals
    </label>
  </div>

  <div class="linreg-stats">
    <span id="lr-equation">y = a x + b</span>
    <span id="lr-r2">R² = —</span>
  </div>

  <svg id="lr-svg" viewBox="0 0 700 430" width="100%" style="max-width:900px; display:block; background:#151218; border-radius:14px; box-shadow:0 6px 22px rgba(255,121,198,.08)"></svg>

  <p class="linreg-note">
    <b>Tip:</b> Drag the magenta points. The least-squares line, equation, and R² update instantly.
    Toggle residuals to see vertical errors from each point to the line.
  </p>
</section>

<style>
  #linreg-demo.linreg-card{
    background:#222025;border-radius:18px;padding:22px 22px 16px 22px;
    border-left:7px solid #ff79c6; box-shadow:0 4px 30px rgba(255,121,198,.09);
  }
  #linreg-demo .linreg-toolbar{
    display:flex;gap:10px;align-items:center;margin:12px 0 10px 0;flex-wrap:wrap;
  }
  #linreg-demo button{
    background:#ff79c6;border:none;color:#1a1d1f;padding:8px 12px;border-radius:10px;
    font-weight:700;cursor:pointer;box-shadow:0 3px 12px rgba(255,121,198,.35)
  }
  #linreg-demo button:hover{ filter:brightness(1.05); }
  #linreg-demo .linreg-toggle{ display:inline-flex;gap:8px;align-items:center; }
  #linreg-demo .linreg-stats{
    display:flex;gap:18px;flex-wrap:wrap;margin:8px 0 14px 0;
    color:#ffb3de;font-weight:600;
  }
  #linreg-demo .linreg-note{ color:#ffb3de;margin-top:10px; }
  /* SVG styles */
  #lr-svg .axis path, #lr-svg .axis line{ stroke:#6a5060; }
  #lr-svg .axis text{ fill:#ffb3de;font-size:12px; }
  #lr-svg .point{ fill:#ff79c6; cursor:grab; }
  #lr-svg .point:active{ cursor:grabbing; }
  #lr-svg .fit-line{ stroke:#fff52e; stroke-width:3; }
  #lr-svg .residual{ stroke:#7fd7ff; stroke-dasharray:4 4; opacity:.9; }
  #lr-svg .grid line{ stroke:#2f2630; }
  #lr-svg .tooltip{
    pointer-events:none; font-size:12px; fill:#111; 
  }
</style>

<script>
(function(){
  // ====== Config ======
  const svg = document.getElementById('lr-svg');
  const W = 700, H = 430, PAD = 50;
  const innerW = W - PAD*2, innerH = H - PAD*2;
  const XMIN=0, XMAX=10, YMIN=0, YMAX=10;

  // Utilities: scales
  const x2px = x => PAD + (x - XMIN) / (XMAX - XMIN) * innerW;
  const y2px = y => H - PAD - (y - YMIN) / (YMAX - YMIN) * innerH;
  const px2x = px => XMIN + (px - PAD) / innerW * (XMAX - XMIN);
  const px2y = py => YMIN + (H - PAD - py) / innerH * (YMAX - YMIN);

  // SVG helpers
  const svgns = "http://www.w3.org/2000/svg";
  const gGrid = mk('g'); const gAxes = mk('g');
  const gResiduals = mk('g'); const gLine = mk('g'); const gPoints = mk('g');
  svg.append(gGrid); svg.append(gAxes); svg.append(gResiduals); svg.append(gLine); svg.append(gPoints);

  // Grid
  drawGrid();

  // Axes
  drawAxes();

  // Data
  let pts = [];
  function seedData(){
    pts = [];
    const a=0.8, b=1.2;
    for(let i=0;i<12;i++){
      const x = rnd(0.5,9.5);
      const y = a*x + b + rnd(-1.2, 1.2);
      pts.push({x,y});
    }
  }
  seedData();

  // UI
  const showResidualsCheckbox = document.getElementById('lr-show-residuals');
  const eqEl = document.getElementById('lr-equation');
  const r2El = document.getElementById('lr-r2');
  document.getElementById('lr-reset').addEventListener('click', ()=>{ seedData(); render(); });
  document.getElementById('lr-add').addEventListener('click', ()=>{
    pts.push({x:rnd(0,10), y:rnd(0,10)}); render();
  });
  showResidualsCheckbox.addEventListener('change', render);

  // Tooltip
  const tip = mk('text', {class:'tooltip', x: 8, y: 18});
  const tipBg = mk('rect', {fill:'#ffb3de', rx:6, ry:6, x:4, y:4, width:120, height:20, opacity:0.9});
  tip.textContent = '';
  svg.append(tipBg); svg.append(tip);

  // Drag state
  let dragging = null;

  // Render
  function render(){
    // Fit line (ordinary least squares)
    const {a, b, r2} = fitLine(pts);

    // Update equation text
    eqEl.textContent = `y = ${fmt(a)} x + ${fmt(b)}`;
    r2El.textContent = `R² = ${fmt(r2,3)}`;

    // Residuals
    gResiduals.innerHTML = '';
    if(showResidualsCheckbox.checked){
      pts.forEach(p=>{
        const yhat = a*p.x + b;
        gResiduals.append(mk('line', {
          class:'residual',
          x1:x2px(p.x), y1:y2px(p.y),
          x2:x2px(p.x), y2:y2px(yhat)
        }));
      });
    }

    // Line segment across plot
    gLine.innerHTML = '';
    const xA = XMIN, yA = a*xA + b;
    const xB = XMAX, yB = a*xB + b;
    const line = mk('line', {
      class:'fit-line',
      x1:x2px(xA), y1:y2px(yA),
      x2:x2px(xB), y2:y2px(yB)
    });
    gLine.append(line);

    // Points
    gPoints.innerHTML = '';
    pts.forEach((p, i)=>{
      const c = mk('circle', {class:'point', r:6, cx:x2px(p.x), cy:y2px(p.y)});
      c.addEventListener('mousedown', (e)=>{ dragging = {i, dx:0, dy:0}; c.style.filter='brightness(1.2)'; });
      svg.addEventListener('mousemove', (e)=>{
        if(dragging && dragging.i===i){
          const pt = getMousePos(svg, e);
          let nx = clamp(px2x(pt.x), XMIN, XMAX);
          let ny = clamp(px2y(pt.y), YMIN, YMAX);
          pts[i] = {x:nx, y:ny};
          c.setAttribute('cx', x2px(nx));
          c.setAttribute('cy', y2px(ny));
          // live update while dragging
          const fit = fitLine(pts);
          eqEl.textContent = `y = ${fmt(fit.a)} x + ${fmt(fit.b)}`;
          r2El.textContent = `R² = ${fmt(fit.r2,3)}`;
          // update line
          const y1 = fit.a*XMIN + fit.b, y2 = fit.a*XMAX + fit.b;
          line.setAttribute('x1', x2px(XMIN));
          line.setAttribute('y1', y2px(y1));
          line.setAttribute('x2', x2px(XMAX));
          line.setAttribute('y2', y2px(y2));
          // update residual (only if shown)
          if(showResidualsCheckbox.checked){
            gResiduals.innerHTML = '';
            pts.forEach(pp=>{
              const yh = fit.a*pp.x + fit.b;
              gResiduals.append(mk('line', {
                class:'residual',
                x1:x2px(pp.x), y1:y2px(pp.y),
                x2:x2px(pp.x), y2:y2px(yh)
              }));
            });
          }
          // tooltip
          showTip(`(${fmt(nx,2)}, ${fmt(ny,2)})`);
        }
      });
      window.addEventListener('mouseup', ()=>{
        if(dragging){ dragging=null; c.style.filter=''; hideTip(); }
      });
      c.addEventListener('mouseenter', ()=> showTip(`(${fmt(p.x,2)}, ${fmt(p.y,2)})`) );
      c.addEventListener('mouseleave', ()=> hideTip() );
      gPoints.append(c);
    });
  }

  // ====== Math: OLS fit (slope a, intercept b, R^2) ======
  function fitLine(data){
    const n = data.length;
    let sx=0, sy=0, sxx=0, syy=0, sxy=0;
    for(const {x,y} of data){
      sx += x; sy += y;
      sxx += x*x; syy += y*y; sxy += x*y;
    }
    const xbar = sx/n, ybar = sy/n;
    const varx = sxx - n*xbar*xbar;
    const covxy = sxy - n*xbar*ybar;
    const a = (varx === 0) ? 0 : (covxy / varx);
    const b = ybar - a*xbar;
    // R^2
    let ss_res = 0, ss_tot = 0;
    for(const {x,y} of data){
      const yhat = a*x + b;
      ss_res += (y - yhat) ** 2;
      ss_tot += (y - ybar) ** 2;
    }
    const r2 = (ss_tot === 0) ? 1 : (1 - ss_res/ss_tot);
    return {a, b, r2};
  }

  // ====== Axes & grid ======
  function drawGrid(){
    const g = mk('g', {class:'grid'});
    // vertical
    for(let x=0; x<=10; x++){
      g.append(mk('line', {x1:x2px(x), y1:y2px(0), x2:x2px(x), y2:y2px(10)}));
    }
    // horizontal
    for(let y=0; y<=10; y++){
      g.append(mk('line', {x1:x2px(0), y1:y2px(y), x2:x2px(10), y2:y2px(y)}));
    }
    svg.append(g);
  }

  function drawAxes(){
    const g = mk('g', {class:'axis'});
    // axes lines
    g.append(mk('line', {x1:PAD, y1:y2px(0), x2:PAD+innerW, y2:y2px(0)}));
    g.append(mk('line', {x1:x2px(0), y1:PAD, x2:x2px(0), y2:PAD+innerH}));
    // ticks & labels
    for(let x=0;x<=10;x+=1){
      const px = x2px(x);
      g.append(mk('line', {x1:px, y1:y2px(0)-4, x2:px, y2:y2px(0)+4}));
      const t = mk('text', {x:px, y:y2px(0)+18, 'text-anchor':'middle'});
      t.textContent = x;
      g.append(t);
    }
    for(let y=0;y<=10;y+=1){
      const py = y2px(y);
      g.append(mk('line', {x1:x2px(0)-4, y1:py, x2:x2px(0)+4, y2:py}));
      const t = mk('text', {x:x2px(0)-10, y:py+4, 'text-anchor':'end'});
      t.textContent = y;
      g.append(t);
    }
    // axis labels
    const xl = mk('text', {x: PAD+innerW/2, y: y2px(0)+40, 'text-anchor':'middle'});
    xl.textContent = 'x';
    const yl = mk('text', {x: x2px(0)-30, y: PAD+innerH/2, 'text-anchor':'middle', transform:`rotate(-90 ${x2px(0)-30} ${PAD+innerH/2})`});
    yl.textContent = 'y';
    svg.append(g);
    svg.append(xl); svg.append(yl);
  }

  // ====== Helpers ======
  function mk(tag, attrs={}){
    const el = document.createElementNS(svgns, tag);
    for(const [k,v] of Object.entries(attrs)) el.setAttribute(k,v);
    return el;
  }
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function fmt(num, d=2){
    if(!isFinite(num)) return '—';
    const s = num.toFixed(d);
    // trim trailing zeros
    return s.replace(/\.?0+$/,'');
  }
  function getMousePos(svgEl, evt){
    const pt = svgEl.createSVGPoint();
    pt.x = evt.clientX; pt.y = evt.clientY;
    const ctm = svgEl.getScreenCTM().inverse();
    return pt.matrixTransform(ctm);
  }
  function showTip(text){
    tip.textContent = text;
    const bb = tip.getBBox();
    tipBg.setAttribute('width', bb.width + 12);
    tipBg.setAttribute('height', bb.height + 10);
  }
  function hideTip(){ tip.textContent=''; tipBg.setAttribute('width', 0); tipBg.setAttribute('height', 0); }

  // Initial render
  render();
})();
</script>



<section id="linreg-pro" class="linreg-card">
  <h3 style="margin-top:0;">Interactive: Tune the Equation & See the Fit</h3>

  <div class="linreg-toolbar">
    <button data-action="reset">Reset points</button>
    <button data-action="add">Add point</button>
    <button data-action="snap" title="Copy least-squares fit into your editable equation">Snap to Fit</button>

    <label class="linreg-toggle">
      <input type="checkbox" data-action="show-resid" />
      Show residuals
    </label>
    <label class="linreg-select">
      Residuals to:
      <select data-role="resid-target">
        <option value="fit">Best-fit</option>
        <option value="user" selected>Your model</option>
      </select>
    </label>
  </div>

  <div class="lr-modes">
    <label class="mode-opt">
      <input type="radio" name="lr-mode" value="linear" checked>
      Linear mode: <span class="mono">y = a·x + b</span>
    </label>
    <label class="mode-opt">
      <input type="radio" name="lr-mode" value="custom">
      Custom mode: <span class="mono">y = f(x)</span>
    </label>
  </div>

  <!-- Linear controls -->
  <div class="lr-controls" data-box="linear">
    <div class="ctrl-row">
      <label>a (slope)</label>
      <input type="range" data-role="a-range" min="-3" max="3" step="0.01" value="1">
      <input type="number" data-role="a-num" min="-10" max="10" step="0.01" value="1">
    </div>
    <div class="ctrl-row">
      <label>b (intercept)</label>
      <input type="range" data-role="b-range" min="-5" max="5" step="0.01" value="0">
      <input type="number" data-role="b-num" min="-10" max="10" step="0.01" value="0">
    </div>
  </div>

  <!-- Custom function controls -->
  <div class="lr-controls" data-box="custom" style="display:none">
    <div class="ctrl-row">
      <label>f(x) =</label>
      <input data-role="expr" value="0.8*x + 1.2" size="30" class="mono">
      <small>Allowed: <span class="mono">x 0-9 + - * / ^ ( ) .</span></small>
    </div>
  </div>

  <div class="linreg-stats">
    <span data-out="eq" class="mono"></span>
    <span data-out="r2fit" class="mono"></span>
    <span data-out="r2user" class="mono"></span>
    <span data-out="mseuser" class="mono"></span>
  </div>

  <svg class="plot" viewBox="0 0 700 430" width="100%" style="max-width:900px; display:block; background:#151218; border-radius:14px; box-shadow:0 6px 22px rgba(255,121,198,.08)"></svg>

  <p class="linreg-note">
    <b>Try this:</b> Drag points, adjust <span class="mono">a</span>/<span class="mono">b</span> or type a custom <span class="mono">f(x)</span>.
    Use <b>Snap to Fit</b> to copy the least-squares line into your controls.
  </p>
</section>

<style>
  /* Scoped styles to avoid collisions */
  #linreg-pro.linreg-card{
    background:#222025;border-radius:18px;padding:22px 22px 16px 22px;
    border-left:7px solid #ff79c6; box-shadow:0 4px 30px rgba(255,121,198,.09);
  }
  #linreg-pro .linreg-toolbar{
    display:flex;gap:10px;align-items:center;margin:12px 0 10px 0;flex-wrap:wrap;
  }
  #linreg-pro button{
    background:#ff79c6;border:none;color:#1a1d1f;padding:8px 12px;border-radius:10px;
    font-weight:700;cursor:pointer;box-shadow:0 3px 12px rgba(255,121,198,.35)
  }
  #linreg-pro button:hover{ filter:brightness(1.05); }
  #linreg-pro .linreg-toggle, #linreg-pro .linreg-select{ display:inline-flex; gap:8px; align-items:center; color:#ffb3de; }
  #linreg-pro .linreg-stats{
    display:flex;gap:18px;flex-wrap:wrap;margin:8px 0 14px 0;
    color:#ffb3de;font-weight:600;
  }
  #linreg-pro .linreg-note{ color:#ffb3de;margin-top:10px; }
  #linreg-pro .lr-modes{ display:flex; gap:22px; margin:8px 0 6px; color:#ffb3de; }
  #linreg-pro .mode-opt{ display:flex; align-items:center; gap:8px; }
  #linreg-pro .lr-controls{ background:#1e1a21; border:1px solid #3a2a34; border-radius:12px; padding:10px 12px; margin:8px 0 12px; }
  #linreg-pro .ctrl-row{ display:grid; grid-template-columns:120px 1fr 110px; gap:10px; align-items:center; margin:6px 0; }
  #linreg-pro input[type="number"], #linreg-pro input[type="text"]{ 
    background:#2a2028; border:1px solid #4a3340; color:#ffb3de; border-radius:8px; padding:6px 8px;
  }
  #linreg-pro input[type="range"]{ width:100%; }
  #linreg-pro .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

  #linreg-pro .plot .axis path, #linreg-pro .plot .axis line{ stroke:#6a5060; }
  #linreg-pro .plot .axis text{ fill:#ffb3de; font-size:12px; }
  #linreg-pro .plot .point{ fill:#ff79c6; cursor:grab; }
  #linreg-pro .plot .point:active{ cursor:grabbing; }
  #linreg-pro .plot .fit-line{ stroke:#fff52e; stroke-width:3; }
  #linreg-pro .plot .user-line{ stroke:#7fd7ff; stroke-width:3; }
  #linreg-pro .plot .user-curve{ fill:none; stroke:#7fd7ff; stroke-width:3; }
  #linreg-pro .plot .residual{ stroke:#7fd7ff; stroke-dasharray:4 4; opacity:.9; }
  #linreg-pro .plot .grid line{ stroke:#2f2630; }
</style>

<script>
(function(){
  const root = document.getElementById('linreg-pro');
  const svg  = root.querySelector('svg.plot');
  const svgns = "http://www.w3.org/2000/svg";

  // Geometry & scales
  const W=700,H=430,PAD=50, innerW=W-PAD*2, innerH=H-PAD*2;
  const XMIN=0,XMAX=10,YMIN=0,YMAX=10;
  const x2px = x => PAD + (x - XMIN)/(XMAX - XMIN)*innerW;
  const y2px = y => H - PAD - (y - YMIN)/(YMAX - YMIN)*innerH;
  const px2x = px => XMIN + (px - PAD)/innerW*(XMAX - XMIN);
  const px2y = py => YMIN + (H - PAD - py)/innerH*(YMAX - YMIN);

  // Groups
  const gGrid = mk('g'); const gAxes = mk('g');
  const gResiduals = mk('g'); const gFit = mk('g'); const gUser = mk('g'); const gPts = mk('g');
  svg.append(gGrid,gAxes,gResiduals,gFit,gUser,gPts);

  // Controls
  const btnReset = root.querySelector('[data-action="reset"]');
  const btnAdd   = root.querySelector('[data-action="add"]');
  const btnSnap  = root.querySelector('[data-action="snap"]');
  const chkResid = root.querySelector('[data-action="show-resid"]');
  const selResidTo = root.querySelector('[data-role="resid-target"]');
  const modeRadios = [...root.querySelectorAll('input[name="lr-mode"]')];

  const linearBox = root.querySelector('[data-box="linear"]');
  const customBox = root.querySelector('[data-box="custom"]');

  const aRange = root.querySelector('[data-role="a-range"]');
  const aNum   = root.querySelector('[data-role="a-num"]');
  const bRange = root.querySelector('[data-role="b-range"]');
  const bNum   = root.querySelector('[data-role="b-num"]');
  const exprInput = root.querySelector('[data-role="expr"]');

  const outEq     = root.querySelector('[data-out="eq"]');
  const outR2fit  = root.querySelector('[data-out="r2fit"]');
  const outR2user = root.querySelector('[data-out="r2user"]');
  const outMSE    = root.querySelector('[data-out="mseuser"]');

  // Draw axes & grid (once)
  drawGrid(); drawAxes();

  // Data
  let pts = [];
  function seedData(){
    pts = [];
    const a=0.8, b=1.2;
    for(let i=0;i<12;i++){
      const x = rnd(0.5,9.5);
      const y = a*x + b + rnd(-1.2,1.2);
      pts.push({x,y});
    }
  }
  seedData();

  // User model state
  let mode='linear';
  let userA=parseFloat(aRange.value);
  let userB=parseFloat(bRange.value);
  let userExpr=exprInput.value;

  // Drag state & one set of listeners (no duplicates!)
  let draggingIndex = null;
  svg.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);

  // Events
  aRange.addEventListener('input', ()=>{ aNum.value=aRange.value; userA=+aRange.value; render(); });
  aNum  .addEventListener('input', ()=>{ aRange.value=aNum.value; userA=+aNum.value;   render(); });
  bRange.addEventListener('input', ()=>{ bNum.value=bRange.value; userB=+bRange.value; render(); });
  bNum  .addEventListener('input', ()=>{ bRange.value=bNum.value; userB=+bNum.value;   render(); });
  exprInput.addEventListener('input', ()=>{ userExpr=exprInput.value; render(); });

  modeRadios.forEach(r=>r.addEventListener('change', ()=>{
    mode = root.querySelector('input[name="lr-mode"]:checked').value;
    linearBox.style.display = (mode==='linear')?'':'none';
    customBox.style.display = (mode==='custom')?'':'none';
    render();
  }));

  btnReset.addEventListener('click', ()=>{ seedData(); render(); });
  btnAdd.addEventListener('click', ()=>{ pts.push({x:rnd(0,10),y:rnd(0,10)}); render(); });
  btnSnap.addEventListener('click', ()=>{
    const {a,b} = fitLine(pts);
    userA=a; userB=b; mode='linear';
    root.querySelector('input[name="lr-mode"][value="linear"]').checked = true;
    linearBox.style.display=''; customBox.style.display='none';
    aRange.value=aNum.value=userA.toFixed(2);
    bRange.value=bNum.value=userB.toFixed(2);
    render();
  });
  chkResid.addEventListener('change', render);
  selResidTo.addEventListener('change', render);

  function onMouseMove(e){
    if(draggingIndex===null) return;
    const pt = getMousePos(svg,e);
    const nx = clamp(px2x(pt.x), XMIN, XMAX);
    const ny = clamp(px2y(pt.y), YMIN, YMAX);
    pts[draggingIndex] = {x:nx, y:ny};
    render(); // re-render once per mousemove
  }
  function onMouseUp(){ draggingIndex=null; }

  function render(){
    // Stats for best-fit
    const fit = fitLine(pts);
    outEq.textContent    = `Best-fit: y = ${fmt(fit.a)}·x + ${fmt(fit.b)}`;
    outR2fit.textContent = `R²_fit = ${fmt(fit.r2,3)}`;

    // User model
    const yh = x => (mode==='linear') ? (userA*x + userB) : evalUserExpr(userExpr, x);
    const ms = modelStats(pts, yh, fit.ybar);
    outR2user.textContent = `R²_your = ${fmt(ms.r2,3)}`;
    outMSE.textContent    = `MSE_your = ${fmt(ms.mse,3)}`;

    // Residuals
    gResiduals.innerHTML='';
    if(chkResid.checked){
      const useYhat = (selResidTo.value==='fit') ? (x)=>fit.a*x+fit.b : yh;
      pts.forEach(p=>{
        const yhat = useYhat(p.x);
        gResiduals.append(mk('line',{
          class:'residual',
          x1:x2px(p.x), y1:y2px(p.y),
          x2:x2px(p.x), y2:y2px(yhat)
        }));
      });
    }

    // Best-fit line
    gFit.innerHTML='';
    gFit.append(mk('line',{
      class:'fit-line',
      x1:x2px(XMIN), y1:y2px(fit.a*XMIN+fit.b),
      x2:x2px(XMAX), y2:y2px(fit.a*XMAX+fit.b)
    }));

    // User model (line/curve)
    gUser.innerHTML='';
    if(mode==='linear'){
      gUser.append(mk('line',{
        class:'user-line',
        x1:x2px(XMIN), y1:y2px(userA*XMIN + userB),
        x2:x2px(XMAX), y2:y2px(userA*XMAX + userB)
      }));
    }else{
      const path = mk('path',{class:'user-curve'});
      const N=160; let d='';
      for(let i=0;i<=N;i++){
        const x = XMIN + (XMAX-XMIN)*i/N;
        const y = yh(x);
        if(!isFinite(y)) continue;
        d += `${i===0?'M':'L'}${x2px(x)},${y2px(y)} `;
      }
      path.setAttribute('d', d);
      gUser.append(path);
    }

    // Points (attach only mousedown; mousemove/up are global)
    gPts.innerHTML='';
    pts.forEach((p,i)=>{
      const c = mk('circle',{class:'point', r:6, cx:x2px(p.x), cy:y2px(p.y)});
      c.addEventListener('mousedown', ()=>{ draggingIndex=i; });
      gPts.append(c);
    });
  }

  // --- Math helpers ---
  function fitLine(data){
    const n=data.length;
    let sx=0,sy=0,sxx=0,syy=0,sxy=0;
    for(const {x,y} of data){ sx+=x; sy+=y; sxx+=x*x; syy+=y*y; sxy+=x*y; }
    const xbar=sx/n, ybar=sy/n;
    const varx=sxx - n*xbar*xbar;
    const covxy=sxy - n*xbar*ybar;
    const a=(varx===0)?0:(covxy/varx);
    const b=ybar - a*xbar;
    let ss_res=0, ss_tot=0;
    for(const {x,y} of data){
      const yhat=a*x+b;
      ss_res += (y-yhat)**2;
      ss_tot += (y-ybar)**2;
    }
    const r2=(ss_tot===0)?1:(1 - ss_res/ss_tot);
    return {a,b,r2,ybar};
  }
  function modelStats(data, yhatFn, ybar){
    let ss_res=0, ss_tot=0;
    for(const {x,y} of data){
      const yh=yhatFn(x);
      const err=y-yh;
      ss_res+=err*err;
      ss_tot+=(y-ybar)**2;
    }
    const mse = ss_res/data.length;
    const r2  = (ss_tot===0)?1:(1 - ss_res/ss_tot);
    return {mse,r2};
  }

  // --- Drawing helpers ---
  function drawGrid(){
    const g=mk('g',{class:'grid'});
    for(let x=0;x<=10;x++) g.append(mk('line',{x1:x2px(x),y1:y2px(0),x2:x2px(x),y2:y2px(10)}));
    for(let y=0;y<=10;y++) g.append(mk('line',{x1:x2px(0),y1:y2px(y),x2:x2px(10),y2:y2px(y)}));
    svg.append(g);
  }
  function drawAxes(){
    const g=mk('g',{class:'axis'});
    g.append(mk('line',{x1:PAD,y1:y2px(0),x2:PAD+innerW,y2:y2px(0)}));
    g.append(mk('line',{x1:x2px(0),y1:PAD,x2:x2px(0),y2:PAD+innerH}));
    for(let x=0;x<=10;x++){
      const px=x2px(x);
      g.append(mk('line',{x1:px,y1:y2px(0)-4,x2:px,y2:y2px(0)+4}));
      const t=mk('text',{x:px,y:y2px(0)+18,'text-anchor':'middle'}); t.textContent=x; g.append(t);
    }
    for(let y=0;y<=10;y++){
      const py=y2px(y);
      g.append(mk('line',{x1:x2px(0)-4,y1:py,x2:x2px(0)+4,y2:py}));
      const t=mk('text',{x:x2px(0)-10,y:py+4,'text-anchor':'end'}); t.textContent=y; g.append(t);
    }
    const xl=mk('text',{x:PAD+innerW/2,y:y2px(0)+40,'text-anchor':'middle'}); xl.textContent='x';
    const yl=mk('text',{x:x2px(0)-30,y:PAD+innerH/2,'text-anchor':'middle',transform:`rotate(-90 ${x2px(0)-30} ${PAD+innerH/2})`}); yl.textContent='y';
    svg.append(g,xl,yl);
  }
  function mk(tag, attrs={}){ const el=document.createElementNS(svgns,tag); for(const [k,v] of Object.entries(attrs)) el.setAttribute(k,v); return el; }

  // --- Utils ---
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function fmt(n,d=2){ if(!isFinite(n)) return '—'; const s=(+n).toFixed(d); return s.replace(/\.?0+$/,''); }
  function getMousePos(svgEl, evt){ const pt=svgEl.createSVGPoint(); pt.x=evt.clientX; pt.y=evt.clientY; const ctm=svgEl.getScreenCTM().inverse(); return pt.matrixTransform(ctm); }
  function evalUserExpr(expr,x){
    const safe = expr.replace(/\s+/g,'').replace(/\^/g,'**');
    if(!/^[0-9xX+\-*/().]+$/.test(safe)) return NaN;
    try{ const f=new Function('x',`return (${safe});`); const y=f(x); return (typeof y==='number' && isFinite(y))?y:NaN; }
    catch{ return NaN; }
  }

  // Initial paint
  render();
})();
</script>

