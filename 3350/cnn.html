<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Introduction to Convolutional Neural Networks (CNNs)</title>
  <style>
    body {
      font-family: 'Roboto',Arial,sans-serif;
      margin: 0;
      background: #17191a;
      color: #ffd7f0;
      line-height: 1.6;
    }

    header {
      background: linear-gradient(135deg, #ff79c6, #a855f7);
      color: white;
      padding: 30px 24px;
      box-shadow: 0 4px 15px rgba(255,121,198,0.3);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 2em;
      font-weight: 700;
    }

    header p {
      margin: 8px 0 0;
      font-size: 1.1em;
      opacity: 0.95;
      color: #f0f0f0;
    }

    main {
      max-width: 1200px;
      margin: 30px auto 40px;
      padding: 0 16px;
    }

    .card {
      background: #222025;
      border-radius: 14px;
      padding: 25px;
      margin-bottom: 25px;
      box-shadow: 0 4px 15px rgba(255,121,198,0.1);
      border-left: 5px solid #ff79c6;
    }

    h2 {
      margin-top: 0;
      font-size: 1.8em;
      color: #ffb3de;
      border-bottom: 2px solid #ff79c6;
      padding-bottom: 12px;
      font-weight: 700;
    }

    h3 {
      margin-top: 1rem;
      font-size: 1.35em;
      color: #ffb3de;
      font-weight: 600;
    }

    h4 {
      font-size: 1.2em;
      color: #ffd7f0;
      margin: 18px 0 10px 0;
      font-weight: 600;
    }

    .tagline {
      font-size: 1.25em;
      color: #f0f0f0;
    }

    .pill {
      display: inline-block;
      font-size: 1.05em;
      padding: 8px 14px;
      border-radius: 999px;
      background: #19121a;
      color: #ff79c6;
      margin-right: 4px;
      border: 1px solid #ff79c6;
      font-weight: 600;
    }

    ul, ol {
      margin-top: 12px;
      margin-bottom: 12px;
      color: #ffd7f0;
      font-size: 1.2em;
    }

    li {
      margin: 10px 0;
    }

    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }

    .flex-col {
      flex: 1 1 280px;
      min-width: 280px;
    }

    .mini-note {
      font-size: 1.05em;
      color: #ffd7f0;
      background: #1e1a20;
      border-left: 4px solid #10b981;
      padding: 14px 14px;
      border-radius: 8px;
      margin-top: 14px;
      line-height: 1.8;
    }

    .highlight {
      background: rgba(255,121,198,0.2);
      padding: 2px 6px;
      border-radius: 4px;
      color: #ff79c6;
      font-weight: 600;
    }

    /* Tables for the convolution demo */
    .grid {
      border-collapse: collapse;
      margin: 14px 0;
    }

    .grid td {
      width: 45px;
      height: 45px;
      text-align: center;
      border: 2px solid #ff79c6;
      font-size: 1.05em;
      font-weight: 500;
      color: #ffd7f0;
      background: #2a252b;
    }

    .grid td.active {
      background: #8be9fd;
      color: #000;
      font-weight: bold;
    }

    .grid td.result {
      background: #50fa7b;
      color: #000;
      font-weight: bold;
    }

    .grid td.kernel {
      background: #ff5555;
      color: #fff;
    }

    .control-panel {
      margin-top: 18px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      font-size: 1.1em;
    }

    button {
      border-radius: 8px;
      border: 2px solid #ff79c6;
      padding: 10px 18px;
      cursor: pointer;
      font-size: 1.05em;
      background: #ff79c6;
      color: #000;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(255,121,198,0.3);
      transition: all 0.2s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255,121,198,0.5);
      background: #ffb3de;
    }

    button:active {
      transform: translateY(0);
    }

    code {
      background: #19121a;
      color: #50fa7b;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 1em;
      border: 1px solid #50fa7b;
    }

    .pipeline {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      margin-top: 14px;
    }

    .pipeline-step {
      flex: 1 1 180px;
      background: #1e1a20;
      border-radius: 8px;
      padding: 12px 14px;
      font-size: 1.05em;
      display: flex;
      align-items: center;
      gap: 10px;
      white-space: nowrap;
      border: 1px solid #ff79c6;
      color: #ffd7f0;
    }

    .pipeline-step span {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: #ff79c6;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #000;
      font-size: 0.85em;
      flex-shrink: 0;
      font-weight: 700;
    }

    .formula-box {
      background: #19121a;
      border-radius: 10px;
      padding: 14px 16px;
      font-size: 1.05em;
      border: 2px dashed #ff79c6;
      margin-top: 14px;
      color: #ffd7f0;
      line-height: 1.8;
    }

    .footer-note {
      margin-top: 18px;
      font-size: 1.05em;
      color: #ffd7f0;
      text-align: right;
      font-style: italic;
    }

    p {
      color: #ffd7f0;
      font-size: 1.15em;
      line-height: 1.9;
    }

    strong {
      color: #ffb3de;
      font-weight: 700;
    }

    /* CNN Architecture Visualization */
    .architecture-svg {
      background: #1e1a20;
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      border: 2px solid #ff79c6;
    }

    @media (max-width: 600px) {
      header h1 {
        font-size: 1.5em;
      }
      .card {
        padding: 18px;
      }
    }

    /* Highlight 2×2 pooling window */
#poolInputGrid td.active-input {
  background: rgba(80, 250, 123, 0.35);
  box-shadow: 0 0 6px rgba(80, 250, 123, 0.7);
  font-weight: bold;
}

/* Highlight output max cell */
#poolOutputGrid td.active-output {
  background: rgba(255, 121, 198, 0.35);
  box-shadow: 0 0 6px rgba(255, 121, 198, 0.7);
  font-weight: bold;
}

  </style>


  <style>
  /* Scope everything to #padding-demo to avoid conflicts */
  #padding-demo .flex-row {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
  }

  #padding-demo .flex-col {
    flex: 1 1 300px;
    min-width: 260px;
  }

  #padding-demo .pad-grid {
    border-collapse: collapse;
    margin: 10px 0;
  }

  #padding-demo .pad-grid td {
    width: 36px;
    height: 36px;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.4);
    font-size: 14px;
    font-family: "JetBrains Mono", monospace;
  }

  #padding-demo .pad-grid td.active-input {
    background: rgba(80,250,123,0.28);
    font-weight: bold;
  }

  #padding-demo .pad-grid td.active-kernel {
    background: rgba(139,233,253,0.25);
    font-weight: bold;
  }

  #padding-demo .pad-grid td.active-output {
    background: rgba(255,121,198,0.35);
    font-weight: bold;
  }

  #padding-demo .padding-toggle {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
  }

  #padding-demo .pad-btn {
    padding: 6px 12px;
    border-radius: 8px;
    cursor: pointer;
    border: 1px solid #8be9fd;
    background: rgba(50,50,70,0.6);
    color: #fff;
    font-weight: bold;
  }

  #padding-demo .pad-btn.active {
    background: linear-gradient(120deg, #50fa7b, #8be9fd);
    color: #000;
  }

  #padding-demo .control-panel {
    margin-top: 10px;
    display: flex;
    gap: 10px;
  }

  #padding-demo .control-panel button {
    padding: 6px 12px;
    border-radius: 8px;
    cursor: pointer;
    background: #ff79c6;
    border: none;
    font-weight: bold;
    color: #000;
  }

  #padding-demo .calc-panel {
    margin-top: 12px;
    background: rgba(30,30,50,0.75);
    border: 1px solid #8be9fd;
    padding: 8px;
    border-radius: 8px;
  }

  #padding-demo .calc-title {
    color: #8be9fd;
    font-weight: bold;
    margin-bottom: 5px;
  }

  #padding-demo pre {
    margin: 0;
    font-family: "JetBrains Mono", monospace;
  }
</style>


</head>
<body>
<section>
  <center><h1><span class="pill"><i class="fas fa-brain"></i> Convolutional Neural Networks (CNN)</span></h1></center>
</section>

<main>

  <!-- 1. Intuition -->
  <section class="card">
    <h2>1. What Is a CNN?</h2>
    <p>
      A <strong>Convolutional Neural Network (CNN)</strong> is a type of neural network that is designed to understand data that has a
      <span class="highlight">grid-like structure</span>, such as: </p>

      <div style="background: rgba(255,121,198,0.15); border: 2px solid #ff79c6; border-radius: 10px; padding: 16px; margin: 14px 0;">
            <ul style="margin: 0;">
              <li>Images (2D grid of pixels)</li>
              <li>Videos</li>
              <li>Audio spectrograms</li>
              <li>Time-series arranged as grids</li>
            </ul>
      </div>

      <p>
      CNNs are especially powerful for <b>computer vision</b> tasks.
      </p>

    <p>
      Instead of connecting every input pixel directly to every neuron (looking at the whole image at once), CNNs use small filters (kernels) that
      <strong>scan</strong> across the image and detect local patterns such as:
    </p>

    <div style="background: rgba(255,121,198,0.15); border: 2px solid #ff79c6; border-radius: 10px; padding: 16px; margin: 14px 0;">
      <ul style="margin: 0;">
        <li>Edges</li>
        <li>Corners</li>
        <li>Textures</li>
        <li>Shapes</li>
        <li>And more...</li>
      </ul>
    </div>

    <p>
    Then it builds up to recognizing full objects like: faces, cats, cars, digits, etc.
  </p>
  </section>


  <section class="card">
    <h2>2. Core Layers of  CNN</h2>
    <p>
      A CNN typically consists of three main types of layers:
    </p>

    <div style="background: rgba(255,121,198,0.15); border: 2px solid #ff79c6; border-radius: 10px; padding: 18px; margin: 18px 0;">
     <ul style="margin: 0; padding-left: 30px;">
       <li><strong>Convolution layers</strong> learn features (e.g., edge detectors).</li>
       <li><strong>Pooling layers</strong> compress information and make the network more robust to small shifts.</li>
       <li><strong>Fully connected layers</strong> combine the learned features to make a final prediction (e.g., "cat" vs "dog").</li>
     </ul>
   </div>

   <p>
     <b>Hierarchical Feature Learning:</b>
     In a CNN, learning happens in stages—earlier layers learn simple patterns, and deeper layers build on those patterns to capture increasingly complex features.
  </p>
     <div style="background: rgba(255,121,198,0.15); border: 2px solid #ff79c6; border-radius: 10px; padding: 18px; margin: 18px 0;">
      <ul style="margin: 0; padding-left: 30px;">
          <li>Layer 1 --> edges</li>
          <li>Layer 2 --> corners or textures</li>
          <li>Layer 3 --> parts (eyes, wheels)</li>
          <li>Layer 4+ --> whole objects</li>
      </ul>
    </div>
  </section>


  <!-- 3. Typical CNN architecture -->
  <section class="card">
    <h2>3. Typical CNN Architecture for Image Classification</h2>
    <p>
      A common structure for image classification (e.g., MNIST digits, CIFAR-10) looks like this:
    </p>


    <!-- CNN Pipeline with Enhanced Styling (Conv + Pool separated) -->

    
<div class="architecture-svg">
  <svg viewBox="0 0 1300 260" style="width:100%; max-width:1300px;" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
        <path d="M0,0 L0,6 L9,3 z" fill="#50fa7b" />
      </marker>
    </defs>

    <!-- Input Layer -->
    <rect x="20" y="70" width="110" height="90" rx="8" fill="#ff79c6" stroke="#ffb3de" stroke-width="2"/>
    <text x="75" y="100" text-anchor="middle" font-size="15" font-weight="bold">Input</text>
    <text x="75" y="123" text-anchor="middle" font-size="12">32×32×3</text>
    <text x="75" y="142" text-anchor="middle" font-size="11" fill="#f8f8f2">RGB image</text>

    <!-- Arrow 1 -->
    <line x1="130" y1="115" x2="180" y2="115" stroke="#50fa7b" stroke-width="3" marker-end="url(#arrow)"/>

    <!-- Conv 1 -->
    <rect x="180" y="40" width="140" height="70" rx="8" fill="#8be9fd" stroke="#50fa7b" stroke-width="2"/>
    <text x="250" y="63" text-anchor="middle" font-size="13" font-weight="bold">Conv 1 + ReLU</text>
    <text x="250" y="80" text-anchor="middle" font-size="11">32 filters, 3×3×3</text>
    <text x="250" y="97" text-anchor="middle" font-size="11">padding = 1 → 32×32×32</text>

    <!-- Pool 1 -->
    <rect x="180" y="130" width="140" height="70" rx="8" fill="#b2f7ff" stroke="#50fa7b" stroke-width="2"/>
    <text x="250" y="155" text-anchor="middle" font-size="13" font-weight="bold">MaxPool 1</text>
    <text x="250" y="173" text-anchor="middle" font-size="11">2×2, stride 2</text>
    <text x="250" y="190" text-anchor="middle" font-size="11">→ 16×16×32</text>

    <!-- Arrow 2 -->
    <line x1="320" y1="115" x2="370" y2="115" stroke="#50fa7b" stroke-width="3" marker-end="url(#arrow)"/>

    <!-- Conv 2 -->
    <rect x="370" y="40" width="150" height="70" rx="8" fill="#8be9fd" stroke="#50fa7b" stroke-width="2"/>
    <text x="445" y="63" text-anchor="middle" font-size="13" font-weight="bold">Conv 2 + ReLU</text>
    <text x="445" y="80" text-anchor="middle" font-size="11">64 filters, 3×3×32</text>
    <text x="445" y="97" text-anchor="middle" font-size="11">padding = 1 → 16×16×64</text>

    <!-- Pool 2 -->
    <rect x="370" y="130" width="150" height="70" rx="8" fill="#b2f7ff" stroke="#50fa7b" stroke-width="2"/>
    <text x="445" y="155" text-anchor="middle" font-size="13" font-weight="bold">MaxPool 2</text>
    <text x="445" y="173" text-anchor="middle" font-size="11">2×2, stride 2</text>
    <text x="445" y="190" text-anchor="middle" font-size="11">→ 8×8×64</text>

    <!-- Arrow 3 -->
    <line x1="520" y1="115" x2="570" y2="115" stroke="#50fa7b" stroke-width="3" marker-end="url(#arrow)"/>

    <!-- Flatten -->
    <rect x="570" y="70" width="140" height="90" rx="8" fill="#ffb3de" stroke="#ff79c6" stroke-width="2"/>
    <text x="640" y="98" text-anchor="middle" font-size="14" font-weight="bold">Flatten</text>
    <text x="640" y="120" text-anchor="middle" font-size="12">8×8×64 = 4096</text>
    <text x="640" y="138" text-anchor="middle" font-size="11">feature vector</text>

    <!-- Arrow 4 -->
    <line x1="710" y1="115" x2="760" y2="115" stroke="#50fa7b" stroke-width="3" marker-end="url(#arrow)"/>

    <!-- Dense -->
    <rect x="760" y="70" width="130" height="90" rx="8" fill="#fff52e" stroke="#ffb3de" stroke-width="2"/>
    <text x="825" y="98" text-anchor="middle" font-size="14" font-weight="bold">Dense</text>
    <text x="825" y="120" text-anchor="middle" font-size="12">128 units</text>
    <text x="825" y="138" text-anchor="middle" font-size="11">+ ReLU</text>

    <!-- Arrow 5 -->
    <line x1="890" y1="115" x2="940" y2="115" stroke="#50fa7b" stroke-width="3" marker-end="url(#arrow)"/>

    <!-- Output -->
    <rect x="940" y="70" width="140" height="90" rx="8" fill="#ff5555" stroke="#ff79c6" stroke-width="2"/>
    <text x="1010" y="98" text-anchor="middle" font-size="14" fill="#fff" font-weight="bold">Output</text>
    <text x="1010" y="120" text-anchor="middle" font-size="12" fill="#fff">10 classes</text>
    <text x="1010" y="138" text-anchor="middle" font-size="11" fill="#fff">softmax</text>

    <!-- Feature Extraction Label -->
    <line x1="180" y1="230" x2="520" y2="230" stroke="#50fa7b" stroke-width="2" stroke-dasharray="5,5"/>
    <text x="350" y="250" text-anchor="middle" font-size="13" fill="#50fa7b" font-weight="bold">
      Feature Extraction (Conv + Pool)
    </text>

    <!-- Classification Label -->
    <line x1="570" y1="230" x2="1080" y2="230" stroke="#fff52e" stroke-width="2" stroke-dasharray="5,5"/>
    <text x="825" y="250" text-anchor="middle" font-size="13" fill="#fff52e" font-weight="bold">
      Classification (Flatten + Dense)
    </text>
  </svg>
</div>

   

    <p>
      From left to right, the image is gradually transformed:
      raw pixels → low-level features (edges) → higher-level features (parts) → compact feature vector →
      final class probabilities.
    </p>

    <div class="pipeline">
      <div class="pipeline-step"><span>1</span>Input image (e.g., 32×32×3)</div>
      <div class="pipeline-step"><span>2</span>Conv1 + ReLU</div>
      <div class="pipeline-step"><span>3</span>Pooling</div>
      <div class="pipeline-step"><span>4</span>Conv2 + ReLU</div>
      <div class="pipeline-step"><span>5</span>Pooling</div>
      <div class="pipeline-step"><span>6</span>Flatten</div>
      <div class="pipeline-step"><span>7</span>Dense (128)</div>
      <div class="pipeline-step"><span>8</span>Output (10 classes)</div>
    </div>

    <h3>Key ideas</h3>
    <ul>
      <li>Early layers learn <strong>local patterns</strong> (edges, corners).</li>
      <li>Deeper layers learn <strong>more abstract features</strong> (eyes, wheels, faces).</li>
      <li>The final fully connected layers combine these to output probabilities for each class.</li>
    </ul>
  </section>

  <!-- 4. Convolution operation -->
  <section class="card">
    <h2>4. Convolution Layer</h2>
    <div class="flex-row">
      <div class="flex-col">
        <h3>2.1 Input Image (Toy Example)</h3>
        <p>
          Below is a small <strong>5×5 "image"</strong> with pixel values. We will slide a <strong>3×3 filter</strong> over it.
        </p>
        <table id="inputGrid" class="grid"></table>

        <h3>2.2 3×3 Filter (Kernel)</h3>
        <p>
          This filter is like a tiny <strong>feature detector</strong>. Here we use a simple edge-like kernel:
        </p>
        <table id="kernelGrid" class="grid"></table>

        <div class="mini-note">
          In a real CNN, the values inside the kernel are <strong>learned</strong> from data by backpropagation.
        </div>
      </div>

      <div class="flex-col">
        <h3>2.3 Output Feature Map</h3>
        <p>
          At each position, we:
        </p>
        <ol>
          <li>Multiply the 3×3 patch by the 3×3 kernel (element-wise).</li>
          <li>Add all 9 products together (dot product).</li>
          <li>Store the result in the corresponding cell of the <strong>output feature map</strong>.</li>
        </ol>
        <table id="outputGrid" class="grid"></table>

        <div class="control-panel">
          <button id="prevBtn">← Previous</button>
          <button id="nextBtn">Next →</button>
          <button id="resetBtn">Reset</button>
          <span id="stepInfo"></span>
        </div>

      </div>
    </div>
  </section>


  <!-- 5. Padding, stride, pooling -->
  <section class="card">
    <h2>5. Padding, Stride, and Pooling</h2>
    <div class="flex-row">
      <div class="flex-col">
        <h3>3.1 Padding</h3>
        <p>
          <strong>Padding</strong> means adding extra pixels (often zeros) around the border of the image.
          This lets the filter visit the edge pixels more fairly.
        </p>
        <ul>
          <li><strong>Valid convolution</strong>: no padding, output is smaller than input.</li>
          <li><strong>Same convolution</strong>: padding chosen so output has the <em>same size</em> as input.</li>
        </ul>
      </div>
      <div class="flex-col">
        <h3>3.2 Stride</h3>
        <p>
          <strong>Stride</strong> is how many pixels we move the filter each step:
        </p>
        <ul>
          <li>Stride 1: move 1 pixel at a time → larger output.</li>
          <li>Stride 2: move 2 pixels at a time → smaller output.</li>
        </ul>
      </div>
      <div class="flex-col">
        <h3>3.3 Pooling</h3>
        <p>
          <strong>Pooling</strong> downsamples the feature maps and makes the network more robust:
        </p>
        <ul>
          <li><strong>Max pooling</strong> (most common): output is the maximum value in a window (e.g., 2×2).</li>
          <li><strong>Average pooling</strong>: output is the average in the window.</li>
        </ul>
        <div class="mini-note">
          Example: 2×2 max pooling with stride 2 cuts a 28×28 feature map to 14×14.
        </div>
      </div>
    </div>
  </section>


  <!-- Padding Demo -->
<section class="card" id="padding-demo">
  <h2>Padding Demo (Valid vs Same)</h2>

  <div class="flex-row">

    <!-- LEFT SIDE -->
    <div class="flex-col">
      <h3>1. Input Image (5×5)</h3>
      <b>
      VALID = No padding <br>
      </b>
      <b>
      SAME = Add padding so output size stays the SAME as input
      </b>

      <p>
        Toggle between <strong>VALID</strong> (no padding) and <strong>SAME</strong> (add zeros around).
      </p>

      <div class="padding-toggle">
        <button id="padValidBtn" class="pad-btn active">VALID (no padding)</button>
        <button id="padSameBtn" class="pad-btn">SAME (pad with zeros)</button>
      </div>

      <table id="padInputGrid" class="pad-grid"></table>

      <h3>2. 3×3 Kernel</h3>
      <table id="padKernelGrid" class="pad-grid"></table>

      <div class="mini-note">
        SAME padding keeps the output size the <strong>same height/width</strong> as the input.
      </div>
    </div>

    <!-- RIGHT SIDE -->
    <div class="flex-col">
      <h3>3. Output Feature Map</h3>

      <table id="padOutputGrid" class="pad-grid"></table>

      <div class="control-panel">
        <button id="padPrevBtn">← Previous</button>
        <button id="padNextBtn">Next →</button>
        <button id="padResetBtn">Reset</button>
      </div>

      <div class="step-info" id="padStepInfo">
        Click <strong>Next →</strong> to begin sliding the kernel.
      </div>

      <div class="calc-panel">
        <div class="calc-title">Step Calculation</div>
        <pre id="padCalcBox"></pre>
      </div>
    </div>
  </div>
</section>


<!-- 5. Pooling Layer (MaxPooling Demo) -->
<section class="card">
  <h2>5. Pooling Layer (Max Pooling)</h2>
  <div class="flex-row">
    <div class="flex-col">
      <h3>3.1 Input Feature Map (Toy Example)</h3>
      <p>
        Below is a small <strong>4×4 feature map</strong>. We will apply <strong>2×2 Max Pooling</strong> with stride 2.
      </p>
      <table id="poolInputGrid" class="grid"></table>

      <div class="mini-note">
        Max pooling does <strong>not learn weights</strong>. It simply takes the
        <strong>maximum value</strong> inside each 2×2 window.
      </div>
    </div>

    <div class="flex-col">
      <h3>3.2 Output After Max Pooling (2×2)</h3>
      <p>
        For each <strong>2×2 window</strong>, we:
      </p>
      <ol>
        <li>Look at a 2×2 patch in the input.</li>
        <li>Find the <strong>maximum</strong> value in that patch.</li>
        <li>Store that maximum in the corresponding cell of the <strong>pooled output</strong>.</li>
      </ol>

      <table id="poolOutputGrid" class="grid"></table>

      <div class="control-panel">
        <button id="poolPrevBtn">← Previous</button>
        <button id="poolNextBtn">Next →</button>
        <button id="poolResetBtn">Reset</button>
        <span id="poolStepInfo"></span>
      </div>

      <div class="mini-note" id="poolCalcBox" style="margin-top: 10px; white-space: pre-wrap; font-family: 'JetBrains Mono', monospace;">
        Click <strong>Next →</strong> to see each 2×2 window and its max.
      </div>
    </div>
  </div>
</section>


  <!-- 6. CNN vs Fully Connected -->
  <section class="card">
    <h2>6. Why CNNs Work Better Than Fully Connected Networks for Images</h2>
    <ul>
      <li><strong>Local connectivity</strong>: each neuron is connected only to a small region (receptive field), not the whole image.</li>
      <li><strong>Weight sharing</strong>: the same kernel is reused across all positions, which:
        <ul>
          <li>Greatly reduces the number of parameters.</li>
          <li>Encodes the idea that a feature is useful anywhere in the image.</li>
        </ul>
      </li>
      <li><strong>Translation invariance</strong>: pooling and weight sharing make predictions less sensitive to small translations in the input.</li>
    </ul>
    <div class="mini-note">
      A 32×32 RGB image has 3,072 input values. A fully connected layer with 1,000 neurons would already
      need over 3 million parameters. CNNs handle this much more efficiently.
    </div>
  </section>


</main>

<script>
  // ================================
  // Simple interactive convolution demo
  // ================================
  const inputData = [
    [1, 1, 1, 0, 0],
    [0, 1, 1, 1, 0],
    [0, 0, 1, 1, 1],
    [0, 0, 1, 1, 0],
    [1, 1, 1, 0, 0]
  ];

  // Simple edge-like kernel
  const kernelData = [
    [1, 0, -1],
    [1, 0, -1],
    [1, 0, -1]
  ];

  const inputGrid = document.getElementById('inputGrid');
  const kernelGrid = document.getElementById('kernelGrid');
  const outputGrid = document.getElementById('outputGrid');
  const stepInfo = document.getElementById('stepInfo');
  const nextBtn = document.getElementById('nextBtn');
  const prevBtn = document.getElementById('prevBtn');
  const resetBtn = document.getElementById('resetBtn');

  const inRows = inputData.length;
  const inCols = inputData[0].length;
  const kSize = kernelData.length;

  const outRows = inRows - kSize + 1;
  const outCols = inCols - kSize + 1;

  // State: current kernel position
  let currentIndex = -1;
  const totalPositions = outRows * outCols;

  function createTable(tbl, data) {
    tbl.innerHTML = '';
    for (let i = 0; i < data.length; i++) {
      const tr = document.createElement('tr');
      for (let j = 0; j < data[0].length; j++) {
        const td = document.createElement('td');
        td.textContent = data[i][j];
        tr.appendChild(td);
      }
      tbl.appendChild(tr);
    }
  }

  function createEmptyOutputTable(rows, cols) {
    outputGrid.innerHTML = '';
    for (let i = 0; i < rows; i++) {
      const tr = document.createElement('tr');
      for (let j = 0; j < cols; j++) {
        const td = document.createElement('td');
        td.textContent = '';
        tr.appendChild(td);
      }
      outputGrid.appendChild(tr);
    }
  }

  function highlightPosition(index) {
    clearHighlights();

    if (index < 0 || index >= totalPositions) {
      stepInfo.textContent = 'Click "Next" to start sliding the kernel.';
      return;
    }

    const row = Math.floor(index / outCols);
    const col = index % outCols;

    for (let i = 0; i < kSize; i++) {
      for (let j = 0; j < kSize; j++) {
        const inCell = inputGrid.rows[row + i].cells[col + j];
        inCell.classList.add('active');
      }
    }

    for (let i = 0; i < kSize; i++) {
      for (let j = 0; j < kSize; j++) {
        const kCell = kernelGrid.rows[i].cells[j];
        kCell.classList.add('kernel');
      }
    }

    let sum = 0;
    for (let i = 0; i < kSize; i++) {
      for (let j = 0; j < kSize; j++) {
        const val = inputData[row + i][col + j];
        const kVal = kernelData[i][j];
        sum += val * kVal;
      }
    }

    const outCell = outputGrid.rows[row].cells[col];
    outCell.textContent = sum;
    outCell.classList.add('result');

    stepInfo.textContent = `Position ${index + 1} of ${totalPositions} (row ${row}, col ${col})`;
  }

  function clearHighlights() {
    for (let i = 0; i < inRows; i++) {
      for (let j = 0; j < inCols; j++) {
        inputGrid.rows[i].cells[j].classList.remove('active');
      }
    }
    for (let i = 0; i < kSize; i++) {
      for (let j = 0; j < kSize; j++) {
        kernelGrid.rows[i].cells[j].classList.remove('kernel');
      }
    }
    for (let i = 0; i < outRows; i++) {
      for (let j = 0; j < outCols; j++) {
        outputGrid.rows[i].cells[j].classList.remove('result');
      }
    }
  }

  nextBtn.addEventListener('click', () => {
    if (currentIndex < totalPositions - 1) {
      currentIndex++;
      highlightPosition(currentIndex);
    }
  });

  prevBtn.addEventListener('click', () => {
    if (currentIndex > 0) {
      currentIndex--;
      highlightPosition(currentIndex);
    }
  });

  resetBtn.addEventListener('click', () => {
    currentIndex = -1;
    createEmptyOutputTable(outRows, outCols);
    clearHighlights();
    stepInfo.textContent = 'Click "Next" to start sliding the kernel.';
  });

  createTable(inputGrid, inputData);
  createTable(kernelGrid, kernelData);
  createEmptyOutputTable(outRows, outCols);
  stepInfo.textContent = 'Click "Next" to start sliding the kernel.';
</script>

<script>
/* -----------------------------
   Padding Demo: VALID vs SAME
--------------------------------*/

const PAD_INPUT = [
  [1, 2, 3, 4, 5],
  [6, 7, 8, 9, 10],
  [11,12,13,14,15],
  [16,17,18,19,20],
  [21,22,23,24,25]
];

const PAD_KERNEL = [
  [1,0,-1],
  [1,0,-1],
  [1,0,-1],
];

let padMode = "valid";
let padPositions = [];
let padStep = -1;

const padInputGrid = document.getElementById("padInputGrid");
const padKernelGrid = document.getElementById("padKernelGrid");
const padOutputGrid = document.getElementById("padOutputGrid");
const padPrevBtn = document.getElementById("padPrevBtn");
const padNextBtn = document.getElementById("padNextBtn");
const padResetBtn = document.getElementById("padResetBtn");
const padStepInfo = document.getElementById("padStepInfo");
const padCalcBox = document.getElementById("padCalcBox");

document.getElementById("padValidBtn").onclick = () => switchPadMode("valid");
document.getElementById("padSameBtn").onclick = () => switchPadMode("same");

function switchPadMode(mode) {
  padMode = mode;
  document.getElementById("padValidBtn").classList.toggle("active", mode==="valid");
  document.getElementById("padSameBtn").classList.toggle("active", mode==="same");
  initPaddingDemo();
}

function buildGrid(elem, rows, cols, data) {
  elem.innerHTML = "";
  for (let r=0; r<rows; r++) {
    const tr = document.createElement("tr");
    for (let c=0; c<cols; c++) {
      const td = document.createElement("td");
      td.dataset.row = r;
      td.dataset.col = c;
      td.textContent = data ? data[r][c] : "";
      tr.appendChild(td);
    }
    elem.appendChild(tr);
  }
}

function padMatrix(mat) {
  if (padMode === "valid") return mat;

  // SAME: add 1 pixel border of zeros
  const h = mat.length, w = mat[0].length;
  const out = [];

  out.push(Array(w+2).fill(0));

  for (let r=0; r<h; r++) {
    out.push([0, ...mat[r], 0]);
  }

  out.push(Array(w+2).fill(0));
  return out;
}

function computeOutputPositions(h, w) {
  const out = [];
  for (let r=0; r<=h-3; r++) {
    for (let c=0; c<=w-3; c++) {
      out.push({r, c});
    }
  }
  return out;
}

function updatePaddingStep(step) {
  padStep = step;
  clearPadHighlights();

  if (step === -1) {
    padStepInfo.innerHTML = `Click <strong>Next →</strong> to begin.`;
    padCalcBox.textContent = "No calculation yet.";
    padPrevBtn.disabled = true;
    padNextBtn.disabled = false;
    return;
  }

  const total = padPositions.length;
  const {r, c} = padPositions[step];

  const outRows = padOutputGrid.rows.length;
  const outCols = padOutputGrid.rows[0].cells.length;

  // Compute all outputs up to current step
  for (let rr=0; rr<outRows; rr++) {
    for (let cc=0; cc<outCols; cc++) {
      if (rr*3+cc <= step) {
        padOutputGrid.rows[rr].cells[cc].textContent =
          computeConvAt(rr, cc);
      }
    }
  }

  // Highlight input and output
  highlightPadWindow(r, c);
  padOutputGrid.rows[r].cells[c].classList.add("active-output");

  padStepInfo.innerHTML =
    `Step <strong>${step+1}</strong> / <strong>${total}</strong> — window at (${r},${c})`;

  padCalcBox.textContent = getConvCalculationText(r, c);

  padPrevBtn.disabled = (step === 0);
  padNextBtn.disabled = (step === total-1);
}

function computeConvAt(r, c) {
  let sum = 0;
  for (let i=0; i<3; i++) {
    for (let j=0; j<3; j++) {
      sum += PAD_PADDED[r+i][c+j] * PAD_KERNEL[i][j];
    }
  }
  return sum;
}

function getConvCalculationText(r, c) {
  let lines = [];
  lines.push(`Patch at (${r},${c})`);
  lines.push("");

  let sum = 0;
  for (let i=0; i<3; i++) {
    let rowLine = "";
    for (let j=0; j<3; j++) {
      const a = PAD_PADDED[r+i][c+j];
      const b = PAD_KERNEL[i][j];
      const prod = a * b;
      sum += prod;
      rowLine += `${a}×${b}=${prod}   `;
    }
    lines.push(rowLine);
  }
  lines.push("");
  lines.push(`Sum = ${sum}`);
  return lines.join("\n");
}

function highlightPadWindow(r, c) {
  for (let i=0; i<3; i++){
    for (let j=0; j<3; j++){
      padInputGrid.querySelector(
        `td[data-row="${r+i}"][data-col="${c+j}"]`
      )?.classList.add("active-input");
    }
  }
}

function clearPadHighlights() {
  padInputGrid.querySelectorAll("td").forEach(td => td.classList.remove("active-input"));
  padKernelGrid.querySelectorAll("td").forEach(td => td.classList.remove("active-kernel"));
  padOutputGrid.querySelectorAll("td").forEach(td => td.classList.remove("active-output"));
}

let PAD_PADDED = [];

function initPaddingDemo() {
  // Build kernel
  buildGrid(padKernelGrid, 3, 3, PAD_KERNEL);

  // Pad input
  PAD_PADDED = padMatrix(PAD_INPUT);

  // Display padded (or not) input
  buildGrid(padInputGrid, PAD_PADDED.length, PAD_PADDED[0].length, PAD_PADDED);

  // Output shape
  const outH = PAD_PADDED.length - 2;
  const outW = PAD_PADDED[0].length - 2;
  buildGrid(padOutputGrid, outH, outW, null);

  // Compute valid positions
  padPositions = computeOutputPositions(PAD_PADDED.length, PAD_PADDED[0].length);

  updatePaddingStep(-1);
}

padPrevBtn.onclick = () => {
  if (padStep > 0) updatePaddingStep(padStep-1);
};
padNextBtn.onclick = () =>
  updatePaddingStep(padStep+1);
padResetBtn.onclick = () =>
  updatePaddingStep(-1);

// Init on load
initPaddingDemo();
</script>

<script>
// ----- Max Pooling Demo (2×2, stride 2 on a 4×4 feature map) -----

// Toy 4×4 input feature map
const poolInput = [
  [1, 3, 2, 0],
  [4, 6, 5, 1],
  [0, 2, 3, 4],
  [1, 1, 0, 2]
];

// Positions for 2×2 windows with stride 2:
// (top-left row, col) of each window
const poolPositions = [
  { r: 0, c: 0 }, // top-left
  { r: 0, c: 2 }, // top-right
  { r: 2, c: 0 }, // bottom-left
  { r: 2, c: 2 }  // bottom-right
];

let poolStep = -1; // -1 = before start

const poolInputGrid = document.getElementById("poolInputGrid");
const poolOutputGrid = document.getElementById("poolOutputGrid");
const poolPrevBtn = document.getElementById("poolPrevBtn");
const poolNextBtn = document.getElementById("poolNextBtn");
const poolResetBtn = document.getElementById("poolResetBtn");
const poolStepInfo = document.getElementById("poolStepInfo");
const poolCalcBox = document.getElementById("poolCalcBox");

// Build a numeric grid into a table
function buildPoolGrid(table, rows, cols, data) {
  table.innerHTML = "";
  for (let r = 0; r < rows; r++) {
    const tr = document.createElement("tr");
    for (let c = 0; c < cols; c++) {
      const td = document.createElement("td");
      td.dataset.row = r;
      td.dataset.col = c;
      if (data) {
        td.textContent = data[r][c];
      }
      tr.appendChild(td);
    }
    table.appendChild(tr);
  }
}

// Pre-compute all pooled values
function computePoolOutput() {
  const out = [
    [0, 0],
    [0, 0]
  ];
  poolPositions.forEach((pos, idx) => {
    const { r, c } = pos;
    const vals = [
      poolInput[r][c],
      poolInput[r][c + 1],
      poolInput[r + 1][c],
      poolInput[r + 1][c + 1]
    ];
    const maxVal = Math.max(...vals);
    const outR = r / 2;
    const outC = c / 2;
    out[outR][outC] = maxVal;
  });
  return out;
}

const poolOutputValues = computePoolOutput();

function clearPoolHighlights() {
  poolInputGrid.querySelectorAll("td").forEach(td => {
    td.classList.remove("active-input");
  });
  poolOutputGrid.querySelectorAll("td").forEach(td => {
    td.classList.remove("active-output");
  });
}

function updatePoolStep(step) {
  poolStep = step;
  clearPoolHighlights();

  if (step === -1) {
    // Initial state
    poolStepInfo.textContent = "Click Next → to see each 2×2 window and its max.";
    poolCalcBox.textContent = "No pooling yet.\nWe will slide a 2×2 window with stride 2 over the 4×4 feature map.";
    // Clear outputs
    poolOutputGrid.querySelectorAll("td").forEach(td => td.textContent = "");
    poolPrevBtn.disabled = true;
    poolNextBtn.disabled = false;
    return;
  }

  const total = poolPositions.length;
  const { r, c } = poolPositions[step];

  // Fill output cells up to current step
  poolOutputGrid.querySelectorAll("td").forEach(td => {
    const rr = Number(td.dataset.row);
    const cc = Number(td.dataset.col);
    const flatIndex = rr * 2 + cc;
    if (flatIndex <= step) {
      td.textContent = poolOutputValues[rr][cc];
    } else {
      td.textContent = "";
    }
  });

  // Highlight the current 2×2 window in the input
  const vals = [];
  for (let i = 0; i < 2; i++) {
    for (let j = 0; j < 2; j++) {
      const rr = r + i;
      const cc = c + j;
      const td = poolInputGrid.querySelector(`td[data-row="${rr}"][data-col="${cc}"]`);
      if (td) td.classList.add("active-input");
      vals.push(poolInput[rr][cc]);
    }
  }
  const maxVal = Math.max(...vals);

  // Highlight the corresponding output cell
  const outR = r / 2;
  const outC = c / 2;
  const outTd = poolOutputGrid.querySelector(`td[data-row="${outR}"][data-col="${outC}"]`);
  if (outTd) outTd.classList.add("active-output");

  // Text explanation
  poolStepInfo.textContent =
    `Step ${step + 1} / ${total}: window at rows ${r}–${r + 1}, cols ${c}–${c + 1}.`;

  poolCalcBox.textContent =
    `Window values:\n` +
    `${poolInput[r][c]}   ${poolInput[r][c + 1]}\n` +
    `${poolInput[r + 1][c]}   ${poolInput[r + 1][c + 1]}\n\n` +
    `Max = ${maxVal}\n` +
    `→ Output(${outR}, ${outC}) = ${maxVal}`;

  // Button states
  poolPrevBtn.disabled = (step === 0);
  poolNextBtn.disabled = (step === total - 1);
}

// Initialize pooling demo
function initPoolingDemo() {
  if (!poolInputGrid || !poolOutputGrid) return;

  buildPoolGrid(poolInputGrid, 4, 4, poolInput);
  buildPoolGrid(poolOutputGrid, 2, 2, null);
  updatePoolStep(-1);

  poolPrevBtn.addEventListener("click", () => {
    if (poolStep > 0) updatePoolStep(poolStep - 1);
  });

  poolNextBtn.addEventListener("click", () => {
    if (poolStep < poolPositions.length - 1) {
      updatePoolStep(poolStep + 1);
    }
  });

  poolResetBtn.addEventListener("click", () => {
    updatePoolStep(-1);
  });
}

// If you already use DOMContentLoaded elsewhere, you can just call initPoolingDemo()
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initPoolingDemo);
} else {
  initPoolingDemo();
}

function updatePoolStep(step) {
  poolStep = step;
  clearPoolHighlights();

  if (step === -1) {
    poolStepInfo.textContent = "Click Next → to start max pooling.";
    poolCalcBox.textContent =
      "Max pooling takes each 2×2 window and finds the maximum value.\nStride = 2.\nOutput = 2×2.";
    poolOutputGrid.querySelectorAll("td").forEach(td => (td.textContent = ""));
    poolPrevBtn.disabled = true;
    poolNextBtn.disabled = false;
    return;
  }

  const total = poolPositions.length;
  const { r, c } = poolPositions[step];

  // Fill output grid up to current step
  poolOutputGrid.querySelectorAll("td").forEach(td => {
    const rr = Number(td.dataset.row);
    const cc = Number(td.dataset.col);
    const index = rr * 2 + cc;
    if (index <= step) {
      td.textContent = poolOutputValues[rr][cc];
    } else {
      td.textContent = "";
    }
  });

  // Highlight 2×2 window in input
  const values = [];
  for (let i = 0; i < 2; i++) {
    for (let j = 0; j < 2; j++) {
      const rr = r + i;
      const cc = c + j;
      const td = poolInputGrid.querySelector(
        `td[data-row="${rr}"][data-col="${cc}"]`
      );
      td.classList.add("active-input");  // highlight

      values.push(poolInput[rr][cc]);
    }
  }

  // Max of the selected 2×2 window
  const maxVal = Math.max(...values);

  // Highlight the output cell
  const outR = r / 2;
  const outC = c / 2;
  const outTd = poolOutputGrid.querySelector(
    `td[data-row="${outR}"][data-col="${outC}"]`
  );
  outTd.classList.add("active-output");

  // Info text
  poolStepInfo.innerHTML = `
    Step <strong>${step + 1}</strong> / ${total} — window at rows
    <strong>${r}–${r + 1}</strong>, cols <strong>${c}–${c + 1}</strong>.
  `;

  // Calculation text
  poolCalcBox.textContent =
    `Window (2×2):\n` +
    `${poolInput[r][c]}   ${poolInput[r][c + 1]}\n` +
    `${poolInput[r + 1][c]}   ${poolInput[r + 1][c + 1]}\n\n` +
    `Max = ${maxVal}\n` +
    `→ Output(${outR}, ${outC}) = ${maxVal}`;

  // Enable/Disable buttons
  poolPrevBtn.disabled = step === 0;
  poolNextBtn.disabled = step === total - 1;
}


</script>


</body>
</html>
