<!DOCTYPE html>
<html>

<head>
	<title>Hard Problems in Computer Science</title>
	<link href="../CSS/3080.css" rel="stylesheet">
</head>

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'>
</script>

<body>

	<div id="main">

		<h1>Chapter 9: Finite-State Machines, Turing Machines </h1>

		<center>
			<h2>Section 9.4 Turing Machines</h2>
		</center>

		<br>
		<br>

		We have spent quite a bit of time discussing what Turing machines can do. By the Church‚ÄìTuring thesis, they can do a
		great deal indeed, although not very efficiently. It is even more important, however, to consider what Turing
		machines <b><font color="red">cannot</font></b> do. Because a Turing machine‚Äôs abilities to perform tasks exceed those of an actual computer,
		if we
		find something no Turing machine can do, then a real computer cannot do it either.
		In fact, by invoking the Church‚ÄìTuring thesis, no algorithm exists to do it, and the task is not computable. The
		type of task we have in mind here is generally that of determining the truth value of each of a number of related
		statements.



		<h1>Halting Problem</h1>

		The halting problem asks whether it is possible to write a program that can determine, for any given program and
		input, whether that program will halt (terminate) or continue running indefinitely. In other words, it is a decision
		problem that seeks to determine if a program will reach a stopping point or run forever.

		The significance of the halting problem lies in its negative answer. Alan Turing showed that there is no algorithmic
		solution to the halting problem: it is undecidable. This means that there is no general-purpose algorithm or
		computer program that can correctly determine whether an arbitrary program will halt or not for all possible inputs.

		This has profound implications for computer science because it shows that there are inherent limits to what can be
		computed algorithmically. It demonstrates that there are problems that simply cannot be solved by any computer
		program, regardless of its computational power. The undecidability of the halting problem highlights the existence
		of fundamental limitations in our ability to reason about program behavior and predict their outcomes.

		The halting problem has also led to further developments in computability theory, such as the notion of Turing
		completeness and the classification of problems into different complexity classes (like the famous P and NP
		classes). It serves as a cornerstone for understanding the boundaries of what is computationally possible and has
		influenced various areas of computer science, including programming languages, compiler design, and formal
		verification techniques.

		<img src="halt-1.png" width="1200" height="">
		<br><br>

		In simpler terms, the Halting Problem is about whether a computer program can analyze another program and accurately predict whether it will stop running or continue running forever. 
		This problem is important because it touches on the limits of what computers can and cannot do.
		
		<br><br>
		<img src="halt-2.png" width="1200" height="">
		<br>
 
		<h3>Question: </h3>
		Can we create a program that checks if another program will stop or run forever?

		<h3>Answer:</h3>
		No, Alan Turing proved it‚Äôs impossible. <b>It‚Äôs undecidable.</b>
		<br>
		<br>
		
		<font size="20px">üëâ</font> <b><font color="blue">This teaches us: Not everything is solvable. There are limits to what computers can do.</font></b>
		<br>

		If problems are solvable, how hard are they?  <br>
		This moves us into complexity theory, which studies how much time, space, and work it takes to solve problems.
		<br>
		
		<h1>Computational Complexity</h1>

		The Halting Problem has catalyzed advancements in computational complexity theory. 
		This branch of theoretical computer science studies the resources required to solve computational problems, 
		such as time and space.
		<br><br>
		The Halting Problem has had a significant influence on the classification of computational problems based on their complexity, 
		leading to the establishment of important complexity classes such as: 
		<br>
		<ul>
			<li><b><font color="blue">P</font></b></li>
			<li><b><font color="blue">NP</font></b></li>
			<li><b><font color="blue">NP-complete</font></b></li>
			<li><b><font color="blue">NP-hard</font></b></li>
		</ul>
		<br>
		As a model of computation, the Turing machine has provided us with a way to prove the existence of unsolvable
		(uncomputable) problems. Not only does the Turing machine help us find the limits of computability, but it can also
		help us classify problems that are computable‚Äîthat have an algorithm for their solution by the amount of work
		required to carry out the algorithm.

		<h2>P, NP, NP-Complete and NP-Hard Problems in Computer Science</h2>
		<!--
		<center>
			<img width="900px" height="250px" src="eg47.png">
		</center>

		<h2>Halting Problem</h2>
		<center>
			<img width="900px" height="300px" src="halt.png">
		</center>

		<h1>Computational Complexity</h1>
-->
		In theoretical computer science, the classification and complexity of common problem definitions have two major
		sets; <font color="red"><b>P</b> which is "Polynomial" time</font> and <font color="red"><b>NP</b> which is "Non-deterministic Polynomial" time</font>. There are also
		<font color="red"><b>NP-Hard</b></font> and <font color="red"><b>NP-Complete</b></font> sets, which we use to express more sophisticated problems. In the case of
		rating from easy to hard, we might label these as "easy", "medium", "hard", and finally "hardest":

		<h2>P</h2>
		<center>
			<img width="800px" height="200px" src="p.png">
		</center>
		<b><font color="red">P is the collection of all sets recognizable by Turing machines in
		polynomial time.</font></b><br>
		P is a set of problems that <b><font color="blue">can be solved</font></b> (deterministic) <b><font color="blue">in Polynomial Time</font></b>.
		

		<h2>NP</h2>

		<center>
			<img width="800px" height="200px" src="np.png">
		</center>
		<b><font color="red">NP is the collection of all sets recognizable by nondeterministic Turing machines in
		polynomial time.</font></b><br>
		NP is a set of problems that <b><font color="blue">can be solved in non-polynomial time</font></b> (typically requiring much more time than polynomial algorithms, such as exponential time), 
		but whose <b><font color="blue">solutions can be verified in polynomial time</font></b>. (eg: Sudoku)
		<br>

		<h2>NP-Complete</h2>
		NP-Complete problems are the <b><font color="blue">hardest problems inside NP</font></b>. 
		<br>
		This means they satisfy two important conditions:
		<ul>
			<li>&star; In NP:  Their solutions can be verified in polynomial time (easy to check once someone gives you a solution).</li>
			<li>&star; In NP-Hard: They are at least as hard as every problem in NP ‚Äî meaning if you can solve one NP-Complete problem quickly (in polynomial time), 
				you can solve all NP problems quickly. (No such algorithm has been found yet)</li>
		</ul>
		
		<h2>NP-Hard</h2>

		NP-Hard is a set of problems that are <b><font color="blue">at least as hard as the hardest problems in NP</font></b>. 
		Unlike NP-Complete problems, NP-Hard problems do not need to be in NP‚Äîmeaning they might not even have a polynomial-time verification method.
		Some are even undecidable, meaning no algorithm can solve them even with unlimited time and resources.
		
		<h2>The Standard Relationship Between P, NP, NP-Complete, NP-Hard</h2>
		
		<center>
			<img width="900px" height="800px" src="np-hard.png">
		</center>
		<br>

		<h2>Comparison of P, NP, NP-Complete, and NP-Hard</h2>
		
		<table style="width:90%">
			  <thead>
			    <tr>
			      <th>Class</th>
			      <th>Solve Quickly (Polynomial Time)?</th>
			      <th>Verify Quickly (Polynomial Time)?</th>
			      <th>Must Be in NP?</th>
			      <th>Hardness</th>
			      <th>Examples</th>
			    </tr>
			  </thead>
			  <tbody>
			    <tr>
			      <td><strong>P</strong></td>
			      <td>‚úÖ Yes</td>
			      <td>‚úÖ Yes</td>
			      <td>‚úÖ Yes</td>
			      <td>Easy</td>
			      <td>Sorting numbers, Dijkstra‚Äôs algorithm</td>
			    </tr>
			    <tr>
			      <td><strong>NP</strong></td>
			      <td>‚ùì Maybe hard to solve</td>
			      <td>‚úÖ Yes</td>
			      <td>‚úÖ Yes</td>
			      <td>Harder than P</td>
			      <td>Sudoku, Hamiltonian Path</td>
			    </tr>
			    <tr>
			      <td><strong>NP-Complete</strong></td>
			      <td>‚ùå Hard to solve</td>
			      <td>‚úÖ Yes</td>
			      <td>‚úÖ Yes</td>
			      <td>Hardest in NP</td>
			      <td>3-SAT, Traveling Salesman (decision version)</td>
			    </tr>
			    <tr>
			      <td><strong>NP-Hard</strong></td>
			      <td>‚ùå Hard to solve</td>
			      <td>‚ùì Maybe not even verifiable</td>
			      <td>‚ùå No</td>
			      <td>At least as hard as NP problems (or harder)</td>
			      <td>Halting Problem, TSP (optimization version)</td>
			    </tr>
			  </tbody>
			</table>


		<h2>Big-O Notation</h2>

		<b><font color="red">Big-O notation</font></b> is used to analyze the time complexity (how the running time of an algorithm increases with input size) 
		and space complexity (how the memory usage of an algorithm increases with input size) of algorithms.
		
		<ul>
			
		<li>O(1) - constant time (The running time or space usage of the algorithm remains constant regardless of the input size.) (Example: accessing a specific element in an array.) </li>
		<li>O(\(log_2(n)\)) - logarithmic time (The running time or space usage grows logarithmically with the input size.) (Example: binary search ) </li>
		<li>O(n) - linear time (The running time or space usage grows linearly with the input size.) (Example: linear search)</li>
		<li>O(\(n^2\)) - quadratic time (The running time or space usage grows quadratically with the input size.) (Example: nested loops )</li>
		<li>O(\(n^k\)) - polynomial time with an exponent k greater than 2 (The runtime or space grows polynomially with the input size, <br> where k is the degree of the polynomial.) (Example: Matrix Multiplication) </li>
		<li>O(\(k^n\)) - exponential time (The running time or space usage grows exponentially with the input size.) (Example: Hamiltonian Circuit)</li>
		<li>O(n!) - factorial-time (The running time or space usage grows factorially with the input size.) (Example: Traveling Salesman Problem (TSP) - Brute Force Solution)</li>
		
		</ul>
		
		<h3>Polynomial Algorithms</h3>
		The first set of problems are polynomial algorithms that we can solve in polynomial time, like logarithmic, linear
		or quadratic time.
		<br>
		eg: Linear Search O(n), Bubble Sort (O(n^2)), Merge Sort (O(nlogn)), Djikstra Algorithm, Matrix Multiplication ...
		<br>
		<h3>NP Algorithms</h3>
		The second set of problems cannot be solved in polynomial time. However, they can be verified or certified in
		polynomial time. We expect these algorithms to have an exponential complexity.
		<br>
		eg: Hamiltonian Path, Sudoku Solving, Integer Factorization, Graph Isomorphism, 
		<br>
		<h3>NP-Complete Algorithms</h3>
		The next set is very similar to the previous set. Taking a look at the diagram, all of these all belong to NP, but
		are among the hardest in the set.
		NP-Complete problems are both in NP and NP-Hard.
		What makes them different from other NP problems is a useful distinction called
		completeness. For an NP problem that's complete, there exists a polynomial-time algorithm that can transform the
		problem into any other NP-complete problem. This transformation requirement is also called reduction. <b><font color="red">In simpler
			terms, if we have an efficient algorithm to solve an NP-Complete problem, we can use it to solve any other problem
			in NP.</font></b> This means that if any NP-Complete problem can be solved in polynomial time, then all problems in NP can be solved in polynomial time.
		<br>
		eg: Traveling Salesman (decision version), Knapsack (decision version), Graph Coloring ...
		<br>
		<br>
		<b>
			<font color="blue">NP-Complete is a subset of NP, and it consists of the most difficult problems within NP.</font>
		</b>
		<h3>NP-Hard Algorithms</h3>
		The last set of problems contains the hardest, most complex problems in computer science. They are not only hard to
		solve but are hard to verify as well. In fact, some of these problems aren't even decidable.
		<br>
		eg: K-means Clustering, Traveling Salesman Problem (optimization version), Halting Problem
		<br>

		<h2>Conclusion</h2>
		<pre>
P problems are quick to solve.
NP problems are quick to verify but slow to solve.
NP-Complete problems are also quick to verify, slow to solve and can be reduced to any other NP-Complete problem.
NP-Hard problems are slow to verify, slow to solve.
		</pre>

		<h2>P =? NP </h2>

		Clearly, P ‚äÜ NP. <B><font color="blue">P is a subset of NP:</font></B> All problems in P are also in NP. 
		If a problem can be solved in polynomial time, it can certainly be verified in polynomial time.
		<br><br>
		Arguably, the biggest open question in theoretical computer science concerns
		the relationship
		between those two classes: <br><br>
		<pre>
			Is P equal to NP?
		</pre>

		Since 2002, William Gasarch has conducted three polls of researchers concerning this and related
		questions.Confidence that P ‚â† NP has been increasing ‚Äì in 2019, 88% believed P ‚â† NP, as opposed to 83% in 2012 and
		61% in 2002. When restricted to experts, the 2019 answers became 99% believed P ‚â† NP. These polls do not imply
		anything about whether P = NP is true, as stated by Gasarch himself: "This does not bring us any closer to solving
		P=?NP or to knowing when it will be solved, but it attempts to be an objective report on the subjective opinion of
		this era."
		<br>
		The <B><font color="blue">P vs. NP</font></b> problem is one of the <B><font color="blue">seven Millennium Prize Problems</font></B>, with a $1 million reward for its solution. 
		Despite decades of research, it remains unresolved.


		<h2>Millennium Prize Problems</h2>
		<a href="https://en.wikipedia.org/wiki/Millennium_Prize_Problems">Millennium Prize Problems</a>

		<h2>Reference</h2>
		<a href="https://www.baeldung.com/cs/p-np-np-complete-np-hard" target="_blank">Hard Problems in Computer Science</a>
		<br>
		<a href="https://en.wikipedia.org/wiki/P_versus_NP_problem" target="_blank">P versus NP problem</a>

		<footer align="center" id="foot01"></footer>
	</div>

</body>

</html>
