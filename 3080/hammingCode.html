<!DOCTYPE html>
<html>

<head>
	<title>7-bit Hamming Code</title>
	<link href="../CSS/3080.css" rel="stylesheet">
</head>

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'>
</script>

<body>

	<div id="main">

		<h1>Chapter X: Binary Encoding Scheme</h1>

		<center>
			<h2>Section X.4 Error-correcting codes</h2>
		</center>

	
		<h1>Binary Encoding</h1>

		Although the binary number system has many practical advantages and is widely used in digital computers, in many
		cases it is convenient to work with the decimal number system, especially when the communication between man
		and the machine is extensive since most numerical data generated by man are in terms of decimal numbers. To simplify
		the communication problem between man and machine, a number of codes have been devised so that the decimal
		digits are represented by sequences of binary digits.


		<h2>Classification of binary codes</h2>
		<ul>
			<li>
				<h3>Weighted Codes</h3>
			</li>
			<ul>
				<li><b>
						<font color="blue">*Binary to Decimal</font>
					</b></li>
				<li><b>
						<font color="blue">*BCD Code</font>
					</b></li>
				<li><b> <font color="blue">*Self-Complementing Code</font>  </b></li>
				<li><b><font color="blue">*Two's complement</font></b></li>
			</ul>
			<li>
				<h3>Non-Weighted Codes</h3>
			</li>
			<ul>
				<li><b>
						<font color="blue">*Excess-3 Code</font>
					</b></li>
				<li><b>
						<font color="blue">*Gray Code</font>
					</b></li>
			</ul>

			<li>
				<h3>Alphanumeric Codes</h3>
			</li>
			<ul>
				<li>*American Standard Code for Information Interchange (ASCII)</li>
				<li>*Extended Binary Coded Decimal Interchange Code (EBCDIC)</li>
			</ul>
			<li>
				<h3>Error Detecting Codes</h3>
			</li>
			<ul>
				<li><b>
						<font color="blue">*Parity Bit</font>
					</b></li>
			</ul>
			<li>
				<h3>Error Correcting Codes</h3>
			</li>
			<ul>
				<li><b>
						<font color="red">*7-Bit Hamming Code</font>
					</b></li>
			</ul>
		</ul>


		<h1>What Is the Goal of 7-bit Hamming Code?</h1>

		<ul>
			<li>To <b><font color="blue">detect and correct single-bit error</font></b> in a binary message.</li>
			<li>To do this, we add extra bits (called <b><font color="blue">parity bits</font></b>) to the original data to create a <b><font color="blue">Hamming Code</font></b>.</li>
		</ul>

		<h1>Error-correcting codes</h1>

		The <b><font color="blue">7-bit Hamming Code</font></b> is a type of error-detecting and error-correcting code that encodes <b><font color="blue">4 bits of data</font></b> into 7 bits by adding <b><font color="blue">3 parity bits</font></b>. 
		It can detect and correct a single-bit error.

		<h3>Structure</h3>
		The 7 bits consist of: 
		<ul>
			<li>1. <b>4 data bits:</b> \(m_1, m_2, m_3, m_4\)</li>
			<li>2. <b>3 parity bits:</b> \(p_1, p_2, p_3\)</li>
		</ul>
		The positions of the parity bits are powers of 2:
		<ul>
			<li><b>\(p_3\)</b>: Bit 1 \((2^0=1)\)</li>
			<li><b>\(p_2\)</b>: Bit 2 \((2^1=2)\)</li>
			<li><b>\(p_1\)</b>: Bit 4 \((2^2=4)\)</li>
		</ul>
		The remaining bits are the data bits:
		<ul>
			<li><b>\(m_1\)</b>: Bit 3 </li>
			<li><b>\(m_2\)</b>: Bit 5 </li>
			<li><b>\(m_3\)</b>: Bit 6 </li>
			<li><b>\(m_4\)</b>: Bit 7 </li>
		</ul>
		Final 7-bit code word:
		<ul>
			<li>\([p_3,p_2,m_1,p_1,m_2,m_3,m_4]\)</li>
		</ul>

		Parity Bit Coverage: Each parity bit is responsible for ensuring even parity (or odd parity, depending on the system) for specific positions in the code.
		These positions are determined by the binary representation of their indices:
		<ul>
			<li>Parity bit <b><font color="blue">\(p_3\)</font></b> checks positions whose binary index has the <b>least significant bit</b> as 1 (<b><font color="blue">1, 3, 5, 7</font></b>).</li>
			<li>Parity bit <b><font color="blue">\(p_2\)</font></b> checks positions whose binary index has the <b>second least significant bit</b> as 1 (<b><font color="blue">2, 3, 6, 7</font></b>).</li>
			<li>Parity bit <b><font color="blue">\(p_1\)</font></b> checks positions whose binary index has the <b>third least significant bit</b> as 1 (<b><font color="blue">4, 5, 6, 7</font></b>).</li>
		</ul>
		
		<h2>7-bit Hamming Code</h2>

		The basic principles in constructing a Hamming error-correcting code are as follows. To each group of \(m\)
		information, or message, digits, \(k\) parity checking digits, denoted \( p_1 \), \(p_2\),... \(p_k\), are added to
		form an \((m+k)\)-digit code. The result of each parity check is recorded as 1 or 0, depending, respectively, on
		whether an error
		has or has not been detected. These parity checks make possible the development of a binary number, \(c_1 c_2
		...c_k\)
		whose value when an error occurs is equal to the decimal value assigned to the location of the erroneous digit, and
		is
		equal to zero if no error occurs. This number is called the position (or location) number.
		<br><br>
		The number \(k\) of digits in the position number must be large enough to describe the location of any of the
		\(m+k\)
		possible single errors, and must in addition take on the value zero to describe the "no error" condition.
		Consequently, \(k\) must satisfy the inequality <b><font color="red">\(2^k
		>= m+k+1\)</font></b>. Thus, for example, if the original message is in BCD,
		where \(m = 4\), then \(k = 3\) and at least three parity checking digits must be added to the BCD code. The
		resultant
		error correcting code thus consists of seven digits. In this case, if the position number is equal to 101, it means
		that an
		error has occurred in position 5. If, however, the position number is equal to 000, the message is correct.
		<br><br>
		In order to be able to specify the checking digits by means of only message digits and independently of each other,
		they are placed in positions \(1,2,4,...,2^{k-1}\). Thus, if \(m = 4\) and \(k = 3\), the checking digits are placed
		in
		positions 1,2, and
		4, while the remaining positions contain the original (BCD) message bits. For example, in the 
		<b><font color="blue">coded message:</font></b>
		<b>
			<font color="red">11</font>
		</b>0<b>
			<font color="red">0</font>
		</b>110
		the parity digits (in boldface) are \(p_1 = 0, p_2 = 1, p_3 = 1\), while the message digits are 0,1,1,0, which
		correspond
		to
		decimal 6.
		<br><br>
		We shall now show how the Hamming code is constructed, by constructing the code for \(m=4\) and \(k=3\). As
		discussed
		above, the parity checking digits must be so specified that, when an error occurs, the position number will take on
		the value assigned to the location of the erroneous digit. 
		<br><br>
		<b><font color="blue">The following table lists the seven error positions and
		the
		corresponding values of the position number:</font></b>
		<br>
		<br>

		<center>
			<img width="400px" height="300px" src="images/hammingCode1.png">
		</center>

		<br>

		It is evident that if an error occurs in position 1, or 3, or 5, or 7, the least significant digit, i.e., \(c_3\),
		of the position
		number must be equal to 1. If the code is constructed so that in every code word the digits in positions 1,3,5, and
		7
		have even parity, then the occurrence of a single error in any one of these positions will cause an odd parity. In
		such
		a case the least significant digit of the position number is recorded as 1. If no error occurs among these digits,
		the
		parity check will show an even parity, and the least significant digit of the position number is recorded as 0.

		<br><br>
		From the above table we observe that an error in position 2, or 3, or 6, or 7 should result in the recording of a 1
		in
		the center of the position number. Hence the code must be designed so that the digits in positions 2,3,6, and 7 have
		even parity. Again, if the parity check of these digits shows an odd parity, the corresponding position number
		digit,
		i.e., \(c_2\), is set to 1; otherwise it is set to 0.
		<br><br>
		Finally, if an error occurs in position 4, or 5, or 6, or 7,
		the
		most significant
		digit of the position number, i.e., \(c_1\), should be a 1. Therefore, if digits 4,5,6, and 7 are designed to have
		even
		parity, an error in any one of these digits will be recorded as a 1 in the most significant digit of the position
		number.


		<h3>To summarize:</h3>
		<font color="blue">
			<pre>
p1 is selected so as to establish even parity in positions 4,5,6,7.
p2 is selected so as to establish even parity in positions 2,3,6,7.
p3 is selected so as to establish even parity in positions 1,3,5,7.
</pre>
		</font>

		<h2>Steps to construct 7-bit hamming code: </h2>
		
		The code can now be constructed by adding the appropriate checking digits to the message digits. Consider, for
		example, the message 0100 (i.e., decimal 4).
		<br><br>

		<center>
			<img width="700px" height="350px" src="images/hammingCode2.png">
		</center>
		<br>
		\(p_1\) is set equal to 1 so as to establish even parity in positions 4, 5, 6, and 7. Similarly, it is evident that
		\(p_2\) must be a 0
		and \(p_3\) a 1, so that even parity is established in positions 2,3,6, and 7 and 1, 3, 5, and 7. The Hamming code
		for
		the
		decimal digits coded in BCD is shown in the following table.
		<br><br>

		<center>
			<img width="700px" height="350px" src="images/hammingCode3.png">
		</center>
		<br>
		<br>
		<h2>Steps to find error location and correction: </h2>
		The error location and correction is performed in the following manner. Suppose, for example, that the sequence
		1101001 is transmitted but, due to an error in the sixth position, the sequence 1101011 is received. The location of
		the error can be determined by performing three parity checks as follows:
		<br>
		<br>
		<center>
			<img width="600px" height="200px" src="images/hammingCode4.png">
		</center>
		<br>

		Thus the position number formed of <b><font color="red">\(c_1 c_2 c_3\)</font></b> is 110, which means that the location of the error is in position
		6. To
		correct the error, the digit in position 6 is complemented, and the correct message 1101001 is obtained.

		
		<h1>Understanding Parity Bit Coverage</h1>

		<h2>Why does \(p_3\) cover positions 1, 3, 5, 7?</h2>

		<center>
			 <table style="width:60%">
        <thead>
            <tr>
                <th>Position</th>
                <th>Binary Representation</th>
                <th>LSB (Least Significant Bit)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>00<b><font color="red">1</font></b></td>
                <td><b><font color="red">1</font></b></td>
            </tr>
            <tr>
                <td>2</td>
                <td>010</td>
                <td>0</td>
            </tr>
            <tr>
                <td>3</td>
                <td>01<b><font color="red">1</font></b></td>
                <td><b><font color="red">1</font></b></td>
            </tr>
            <tr>
                <td>4</td>
                <td>100</td>
                <td>0</td>
            </tr>
            <tr>
                <td>5</td>
                <td>10<b><font color="red">1</font></b></td>
                <td><b><font color="red">1</font></b></td>
            </tr>
            <tr>
                <td>6</td>
                <td>110</td>
                <td>0</td>
            </tr>
            <tr>
                <td>7</td>
                <td>11<b><font color="red">1</font></b></td>
                <td><b><font color="red">1</font></b></td>
            </tr>
        </tbody>
    </table>
		</center>
		<br>
		Parity bit \(p_3\) (in position 1) is responsible for ensuring even parity for all positions where the <b>Least Significant Bit (LSB)</b> is 1. 
		From the table above, positions 1,3,5,7 have their LSB set to 1, so \(p_3\) covers those positions.
		If an error occurs in position 1, 3, 5, or 7, the least significant bit of the position number — that is, \(c_3\( — will be 1.
		
		<h2>Why does \(p_2\) cover positions 2, 3, 6, 7?</h2>

		<center>
			<table style="width:60%">
        <thead>
            <tr>
                <th>Position</th>
                <th>Binary Representation</th>
                <th>Second LSB</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>001</td>
                <td>0</td>
            </tr>
            <tr>
                <td>2</td>
                <td>0<b><font color="red">1</font></b>0</td>
                <td><b><font color="red">1</font></b></td>
            </tr>
            <tr>
                <td>3</td>
                <td>0<b><font color="red">1</font></b>1</td>
                <td><b><font color="red">1</font></b></td>
            </tr>
            <tr>
                <td>4</td>
                <td>100</td>
                <td>0</td>
            </tr>
            <tr>
                <td>5</td>
                <td>101</td>
                <td>0</td>
            </tr>
            <tr>
                <td>6</td>
                <td>1<b><font color="red">1</font></b>0</td>
                <td><b><font color="red">1</font></b></td>
            </tr>
            <tr>
                <td>7</td>
                <td>1<b><font color="red">1</font></b>1</td>
                <td><b><font color="red">1</font></b></td>
            </tr>
        </tbody>
    </table>
		</center>
		<br>
		Parity bit \(p_2\) (in position 2) is responsible for ensuring even parity for all positions where the <b>Second Least Significant Bit (second LSB)</b> is 1. 
		From the table above, positions 2,3,6,7 have their second LSB set to 1, so \(p_3\) covers those positions.
		
		
		<h2>Why does \(p_1\) cover positions 4, 5, 6, 7?</h2>
		
		<center>
			   <table style="width:60%">
        <thead>
            <tr>
                <th>Position</th>
                <th>Binary Representation</th>
                <th>Third LSB</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>001</td>
                <td>0</td>
            </tr>
            <tr>
                <td>2</td>
                <td>010</td>
                <td>0</td>
            </tr>
            <tr>
                <td>3</td>
                <td>011</td>
                <td>0</td>
            </tr>
            <tr>
                <td>4</td>
                <td><b><font color="red">1</font></b>00</td>
                <td><b><font color="red">1</font></b></td>
            </tr>
            <tr>
                <td>5</td>
                <td><b><font color="red">1</font></b>01</td>
                <td><b><font color="red">1</font></b></td>
            </tr>
            <tr>
                <td>6</td>
                <td><b><font color="red">1</font></b>10</td>
                <td><b><font color="red">1</font></td>
            </tr>
            <tr>
                <td>7</td>
                <td><b><font color="red">1</font></b>11</td>
                <td><b><font color="red">1</font></td>
            </tr>
        </tbody>
    </table>
		</center>

		<br>
		Parity bit \(p_1\) (in position 4) is responsible for ensuring even parity for all positions where the <b>Third Least Significant Bit (third LSB)</b> is 1. 
		From the table above, positions 4,5,6,7 have their third LSB set to 1, so \(p_1\) covers those positions.
		
		
		<h2>Reference</h2>
		<a href="https://www.tutorialspoint.com/computer_logical_organization/binary_codes.htm#:~:text=Binary%20Coded%20Decimal%20(BCD)%20code&text=BCD%20is%20a%20way%20to,1111%20are%20invalid%20in%20BCD."
			target="_blank">Binary Codes</a>
		<br>

		<a href="https://www.geeksforgeeks.org/gray-to-binary-and-binary-to-gray-conversion/" target="_blank">Gray to
			Binary and Binary to Gray conversion</a>

		<br>
		<br>

		<footer align="center" id="foot01"></footer>
	</div>

</body>

</html>
