<!DOCTYPE html>
<html>

<head>
	<title>Decision Trees</title>
	<link href="../CSS/3080.css" rel="stylesheet">
</head>

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'>
</script>

<body>

	<div id="main">

		<h1>Chapter 6: Graphs and Trees</h1>

		<center>
			<h2>Section 6.3 Decision Trees</h2>
		</center>

		<br>
		<br>

		We learn decision trees when studying the lower bound of searching and sorting because they provide a visual 
		and theoretical framework to understand the minimum number of comparisons required to solve these problems.
		
		<h2>Decision Tree</h2>
		The concept of using a decision tree for sorting follows a similar structure as with searching algorithms, 
		but instead of comparing a target value to items in a list, you are comparing pairs of items within the list to determine their order.
		<br><br>
		A <b>
			<font color="blue">decision tree</font>
		</b> is a tree in which the internal nodes represent actions, the arcs represent outcomes of an action and the
		leaves represent final outcomes.
		<br>
		<br>
		Sometimes useful information can be obtained by using a decision tree to represent the activities of a real
		algorithm; actions that the algorithm performs take place at internal nodes, the children of an internal node
		represent the next action taken, based on the outcome of the previous action, and the leaves represent some sort of
		circumstance that can be inferred upon algorithm termination.
		<br>
		<br>
		<h1>Decision Tree in Sorting Algorithms</h1>
		In <b><font color="blue">sorting algorithms</font></b>, a <b><font color="blue">decision tree is a theoretical model</font></b> that helps us understand the <b><font color="blue">minimum number of comparisons</font></b> needed to 
		sort a list using <b><font color="blue">comparison-based sorting algorithms like merge sort, quick sort, or bubble sort</font></b>.
		<br><br>
		In the context of sorting algorithms, a decision tree is a conceptual tool used to represent 
		all possible comparisons that a comparison-based sorting algorithm might make to sort 
		a given set of elements. The tree helps visualize the sorting process by showing the 
		sequence of comparisons, with each path from the root to a leaf representing a 
		possible outcome (sorted order).
		<br>
		<h2>Sorting</h2>
		Decision trees can also model algorithms that sort a list of items by a sequence of comparisons between two items
		from the list. The internal nodes of such a decision tree are labeled L[i]:L[j] to indicate a comparison of list
		item i to list item j. To simplify our discussion, let's assume that the list does not contain duplicate items. Then
		the outcome of such a comparison is either L[i] < L[j] or L[i]> L[j]. If L[i] < L[j], the algorithm proceeds to the
				comparison indicated at the left child of this node; if L[i]> L[j], the algorithm proceeds to the right child.
				If no child exists, the algorithm terminates because the sorted order has been determined. The tree is a binary
				tree, and the leaves represent the final outcomes, that is, the various sorted orders.

				<br>
				<center>
					<img width="60%" src="images/sorting1.png">
				</center>

				<br>

				A decision tree models every possible sequence of comparisons that could happen while sorting n elements.
				<ul>
					<li>&clubs; Each <b><font color="blue">node</font></b> in the tree represents a <b><font color="blue">comparison</font></b> (e.g., "Is L[1] > L[2]?").</li>
					<li>&clubs; Each <b><font color="blue">branch</font></b> shows the result of the comparison (yes/no or true/false).</li>
					<Li>&clubs; Each <b><font color="blue">leaf node</font></b> represents one possible <b><font color="blue">sorted order</font></b> of the array.</Li>
				</ul>
			
				<Br>
				<b>
					<font color="blue"><a href="https://xinyangmtsu.github.io/3080/bubbleSort.html"
							target="_blank">Bubble Sorting Demo</a></font>
				</b>

				<br>
				<br>

<table style="width:80%; margin:auto">
  <caption><strong>Bubble Sort Time Complexity</strong></caption>
  <tr>
    <th>Case</th>
    <th>Time Complexity</th>
    <th>Explanation</th>
  </tr>
  <tr>
    <td>Best Case</td>
    <td>O(n<sup>2</sup>)</td>
    <td>Array is already sorted; n(n - 1)/2 comparisons, 0 swaps.</td>
  </tr>
  <tr>
    <td>Average Case</td>
    <td>O(n<sup>2</sup>)</td>
    <td>Random order; n(n - 1)/2 comparisons.</td>
  </tr>
  <tr>
    <td>Worst Case</td>
    <td>O(n<sup>2</sup>)</td>
    <td>Array is in reverse order; maximum number of swaps and comparisons.</td>
  </tr>
</table>

<h2>Understanding \( \frac{n\times(n-1)}{2} \) comparisons</h2>
<ul>
	<li>&clubs; On the 1st pass, it does n−1 comparisons</li>
	<li>&clubs; On the 2nd pass, it does n−2 comparisons</li>
	<li>&clubs; On the 3rd pass, it does n−3 comparisons</li>
	<li>\(\dots\)</li>
	<li>&clubs; On the (n−1)th pass, it does 1 comparison</li>
	<li>&clubs; So the total number of comparisons is: \(1 + 2 + \dots + n-1 = \frac{n\times(n-1)}{2} \)</li>
</ul>

				

				<h1>Lower Bound for Sorting</h1>
				<b>
					<font color="blue" size="5">Theorem: On the Lower Bound for Sorting
				</b>
				</font>
				<br>
				<font color="blue">
					Any algorithm that sorts an n-element list by comparing paris of items from the list must do at least <b>
						<font color="red" size="4">&lceil;\(log_2 n!\)&rceil;</font>
					</b> comparisons in the worst case.
				</font>
				<br>
				<Br>
				This theorem gives us a lower bound on the number of comparisons required in the worst case for any algorithm
				that uses comparisons to solve the sorting problem.
				<br>
				<br>
				(Lower bound means no algorithm can get faster than this no matter what, so if an algorithm actually does this,
				then it is optimal for worst case scenario)
				<br>
				<b>
					<font color="red" size="5">Note:</font>
				</b>
				<br>
				(1) <b>
					<font size="5">&lceil;&rceil;</font>
				</b> means ceiling. The ceiling is the smallest integer that is greater than or equal to the number inside the
				ceiling signs.<br>
				For example: <Br>
				<b>
					<font size="4">&lceil;2.9&rceil;=3</font>
				</b> <Br>
				<b>
					<font size="4">&lceil;2.4&rceil;=3</font>
				</b> <br>
				<b>
					<font size="4">&lceil;2&rceil;=2</font>
				</b> <Br>
				<br>
				(2) <b>log</b> is actually base 2 even though they didn't put the base in the statement of the theorem.It is
				stated elsewhere. <Br>
				<Br>
				(3) <b>\(log_2x = y\)</b> means \(2^y=x\) so <b>\(log_2 n\)</b> means that we want the exponent we would need to
				put on 2 in order to get n. <Br>
				<Br>
				(4) Example 1:<br>
				Any algorithm that solves the sorting problem for a <b><font color="blue">3-element</font></b> list by comparing Paris of items
				from the list must do at least __________ comparisons in the worst case. <br>
				Solution: <b>
					<font size="4">&lceil;\(log_2 3!\) &rceil; = &lceil; \(log_2 6\)&rceil; = &lceil;2.???&rceil; = 3
					</font>
				</b>
				<br>
				<br>
				How did we get this? The table below has powers of 2 up to \(2^{13}\), and if we want to know the value of x
				when \(2^x=6\) (because log 6 = x means \(2^x=6\)), then looking in the table (4 < 6 < 8), so x must between 2
					and 3. Because of the ceiling, <b>
					<font size="4">&lceil;2.???&rceil; = 3</font></b>, we don't have to know the value of the ????.
					<br>
					<br>
					<center>
						<table style="width:20%">
							<tr>
								<th>x</th>
								<th>\(2^x\)</th>
							</tr>
							<tr>
								<th>1</th>
								<th>2</th>
							</tr>
							<tr>
								<th>2</th>
								<th>4</th>
							</tr>
							<tr>
								<th>3</th>
								<th>8</th>
							</tr>
							<tr>
								<th>4</th>
								<th>16</th>
							</tr>
							<tr>
								<th>5</th>
								<th>32</th>
							</tr>
							<tr>
								<th>6</th>
								<th>64</th>
							</tr>
							<tr>
								<th>7</th>
								<th>128</th>
							</tr>
							<tr>
								<th>8</th>
								<th>256</th>
							</tr>
							<tr>
								<th>9</th>
								<th>512</th>
							</tr>
							<tr>
								<th>10</th>
								<th>1024</th>
							</tr>
							<tr>
								<th>11</th>
								<th>2048</th>
							</tr>
							<tr>
								<th>12</th>
								<th>4096</th>
							</tr>
							<tr>
								<th>13</th>
								<th>8192</th>
							</tr>
						</table>
					</center>
					<br>
					(5) Example 2: <br>
					Any algorithm that solves the sorting problem for a <b><font color="blue">5-element</font></b> list by comparing paris of items
					from the list must do at least __________ comparisons in the worst case. <br>
					Solution: <b>
						<font size="4">&lceil;\(log_2 5!\) &rceil; = &lceil; \(log_2 120\)&rceil; = &lceil;6.???&rceil; = 7
						</font>
					</b>
					<br>
					<br>
					(6) Example 3: <br>
					Any algorithm that solves the sorting problem for a <b><font color="blue">7-element</font></b> list by comparing paris of items
					from the list must do at least __________ comparisons in the worst case. <br>
					Solution: <b>
						<font size="4">&lceil;\(log_2 7!\) &rceil; = &lceil; \(log_2 5040\)&rceil; = &lceil;12.???&rceil; = 13
						</font>
					</b>
					<br>


					<h2>Reference</h2>
					<a href="https://learn.saylor.org/course/view.php?id=67" target="_blank">saylor academy</a>


					<footer align="center" id="foot01"></footer>
	</div>

</body>

</html>
