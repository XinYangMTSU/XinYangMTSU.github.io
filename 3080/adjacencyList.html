<!DOCTYPE html>
<html>

<head>
	<title>Graphs and Trees</title>
	<link href="../CSS/3080.css" rel="stylesheet">
</head>

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'>
</script>

<body>

	<div id="main">

		<h1>Chapter 6: Graphs and Trees</h1>

		<center>
			<h2>Section 6.1 Graphs and Their Representations</h2>
		</center>

		<br>
		<br>

		<h1>Computer Representation of Graphs</h1>
		We have said that the major advantange of a graph is its visual representation of information. What if we want to
		store a graph in digital form? Although it is possible to store a digital image of a graph, it takes a lot of sapce.
		Furthermore, such an image remains but a picture --- the data it represents can't be manipulated in any way. What we
		need to store are these essential data that are part of the definition of a graph -- what the nodes are and which
		nodes have connecting arcs. From this information a visual representation could be reconstructed if desired. The
		usual computer representations of a graph invovle one of two data structures, either an adjacency matrix or an
		adjacency list.

		<br><br>
		Many graphs, far from being complete graphs, have relatively few arcs. Such graphs have sparse adjacency matrices;
		that is, the adjacency matrices contain many zeros. A graph with relatively few arcs can be represented more
		efficiently by stor- ing only the nonzero entries of the adjacency matrix. This representation consists of a list
		for each node of all the nodes adjacent to it. Pointers are used to get us from one item in the list to the next.
		Such an arrangement is called a <font color="blue"><b>linked list</b></font>. There is an array of n pointers, one
		for each node, to get each list started. This <font color="red"><b>adjacency list</b></font> representation,
		although it requires extra storage for
		the pointers, may still be more efficient than an adjacency matrix.

		<h2>Adjacent List</h2>
		An <b><font color="blue">adjacency list</font></b> is a collection of <b><font color="blue">linked lists</font></b>, 
		where each node stores a <b><font color="blue">list of adjacent vertices</font></b> (i.e., the nodes it's connected to).
		<br><br>
		
		Many graphs, far from being complete graphs, have relatively few arcs. Such graphs have <b>sparse</b> adjacency
		matrices; that is, the adjacency matrices contain many zeros. <Br>
		A graph with relatively few arcs can be represented more efficiently by storing only the nonzero entries of the
		adjacency matrix. This representation consists of a list for each node of all the nodes adjacent to it. Pointers are
		used to get us from one item in the list to the next. Such an arrangement is called a <b>
			<font color="blue">linked list</font>
		</b>. There is an array of n pointers, one for each node, to get each list started. This <b>
			<font color="blue">adjacency list</font>
		</b> representation, although it requires extra storage for the pointers, may still be more efficient than an
		adjacency matrix.
		<Br>
		<Br>

		<b>
			<font color="blue">Example 1: Undirected Graph</font>
		</b>
		<hr>
		The following figure shows two representations of an undirected graph. (a) An undirected graph G with 5 vertices and
		7 edges. (b) An adjacency-list representation of G. (c) The adjacency-matrix representation of G.
		<br>
		<Br>
		<center>
			<img width="500px" height="200px" src="images/adjacencyList1.png">
			<br>
			<caption>Figure 1</caption>
		</center>
		The adjacency list for the graph in Figure 1 contains a five-element array of pointers, one for each node. The
		pointer for each node points to an adjacent node, which points to another adjacent node, and so forth. In the figure
		the dot indicates <b>a null pointer</b>, meaning that there is nothing more to be pointed to or that the end of the
		list has been reached. We have dealt with parallel arcs by listing a given node more than once on the adjaceny list
		for \(n_i\) if there is more than one arc between \(n_i\) and that node.
		<br>
		<b>
			<font color="red">
				Note that the arrow in list 3 from the 2 node to the 4 node does not mean that
				there is an arc from node 2 to node 4; all the elements in the node 3 list
				are adjacent to node 3, not necessarily to each other.
			</font>
		</b>
		<br>
		<a href="https://xinyangmtsu.github.io/3080/code/adjList1.cpp" target="_blank">adjacencyList.cpp</a>
		<br>
		<br>
		<b>
			<font color="blue">Example 2: Directed Graph </font>
		</b>
		<hr>
		The following figure shows two representations of a directed graph. (a) A directed graph G with 6 vertices and 8
		edges. (b) An adjacency-list representation of G. (c) The adjacency-matrix representation of G.
		<center>
			<img width="500px" height="200px" src="images/adjacencyList2.png">
			<br>
			<caption>Figure 2</caption>
			<caption><a href="https://notes.shichao.io/clrs/" target="_blank">Reference</a></caption>
		</center>

		<br>
		<br>

		<b>
			<font color="blue">Example 3: Weighted Directed Graph </font>
		</b>
		<hr>
		Figure 6.29a shows a weighted directed graph. The adjacency list representation for this graph is shown in Figure
		6.29b. For each record in the list, the first data item is the node, the second is the weight of the arc to that
		node, and the third is the pointer. Note that entry 4 in the array of startup pointers is null because there are no
		arcs that begin at node 4. <br>
		<br><br>
		<center>
			<img width="500px" height="200px" src="images/arrayPointer1.png">
		</center>
		<br>
		<br>
		<table style="width:80%; margin: auto;">
		    <tr>
		        <th>✅ Advantages</th>
		        <th>❌ Disadvantages</th>
		    </tr>
		    <tr>
		        <td>✅  Space-efficient: Uses only O(V + E) memory, ideal for sparse graphs.</td>
		        <td>❌ Slower edge lookup: Checking if an edge exists may take O(V) in the worst case.</td>
		    </tr>
		    <tr>
		        <td>✅  Efficient for iterating neighbors: Finding all edges of a node is O(degree of node), which is faster than scanning a whole matrix.</td>
		        <td></td>
		    </tr>
		</table>

		<br>

		<h2>Practice</h2>
		Please find the adjacency list:
		<center>
			<img width="500px" height="300px" src="images/adjList.png">
		</center>

		<h2>Real-Life Application of Adjacency List: Social Network Friendships</h2>
		A common real-world use case for an adjacency list is in social networks, such as Facebook, LinkedIn, or Twitter. In these platforms:
		<ul>
			<li><b><font color="blue">Users</font></b> are represented as <b><font color="blue">nodes (vertices)</font></b>.</li>
			<li><b><font color="blue">Friendships (or follow relationships)</font></b> are represented as <b><font color="blue">edges</font></b>.</li>
			<Li>Since each user only connects to a small subset of all users, storing relationships in an adjacency matrix (which takes O(V²) space) is inefficient.</Li>
			<li>An <b><font color="blue">adjacency list</font></b> is the preferred approach since it scales well with millions of users.</li>
			<li>Design a social network system where:</li>
			<ul>
				<Li>Users can <b><font color="blue">connect as friends</font></b>.</Li>
				<li>The system can <b><font color="blue">display a user's friends</font></b>.</li>
				<Li>The system can <b><font color="blue">suggest new friends</font></b> (friends of friends).</Li>
			</ul>
		</ul>

		<h3>C++ Implementation: Social Network Graph Using Adjacency List</h3>
		
		<a href="SocialNetwork.h" target="_blank">SocialNetwork.h</a><br>
		<a href="SocialNetwork.cpp" target="_blank">SocialNetwork.cpp</a><br>
		<a href="main.cpp" target="_blank">main.cpp</a><br>
		<br>

		<h2>Reference</h2>

		<a href="https://learn.saylor.org/course/view.php?id=67" target="_blank">saylor academy</a>

		<footer align="center" id="foot01"></footer>
	</div>

</body>

</html>
