<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Prism.js CSS for styling -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <link href="../CSS/Site.css" type="text/css" rel="stylesheet">
    <title>React Syntax Guide</title>
</head>
<body>

    <div id="main">
        
    <h1>Introduction to React Syntax</h1>

    <h2>1. JSX (JavaScript XML)</h2>
    <p>JSX allows writing HTML-like syntax inside JavaScript. It makes React code easier to read and write.</p>

    <h3>Example without JSX (Regular JavaScript)</h3>
    <pre><code>const element = React.createElement("h1", null, "Hello, React!");</code></pre>
    <p>This is how you would write React elements without JSX.</p>
        <pre>
        //App.js
        <code class="language-jsx">
        import React from "react";

        function App() {
          // Creating an element using React.createElement
          const element = React.createElement("h1", null, "Hello, React!");

          return element;
        }

        export default App;
        </code>
        </pre>
    <h3>Example with JSX</h3>
    <pre><code>const element = &lt;h1&gt;Hello, React!&lt;/h1&gt;;</code></pre>
    <p>We can rewrite the above example using JSX, which makes it more readable and concise. This is the same as 
        the previous example but using JSX.</p>
    <pre>
         //App.js
        <code class="language-jsx">
            import React from "react";

            function App() {
              return &lt;h1&gt;Hello, React!&lt/h1&gt;;
            }
            
            export default App;
        </code>
    </pre>

    <h2>Key JSX Rules:</h2>

    <h3>Understanding the "Only One Parent Element" Rule in JSX</h3>
        
    In <b><font color="blue">JSX (JavaScript XML)</font></b>, a component must return a <b><font color="blue">single parent element</font></b>. 
    This is because <b><font color="blue">JSX expressions must have one root element</font></b>. If you try to return multiple 
    elements without a parent container, you'll get an error.

    <h3>Incorrect JSX (Will Cause an Error)</h3>
    The following code <b><font color="blue">won't work</font></b> because it returns two sibling elements without a parent wrapper:
    <pre>
         <code class="language-jsx">
             function App() {
              return (
                &lt;h1&gt;Title&lt;/h1&gt;
                &lt;p&gt;Paragraph&lt;/p&gt;
              );
            }
            
            export default App;
         </code>
    </pre>
    &#10060; Error: JSX expressions must have one parent element

    <h3>Using a &lt;div&gt; as a Parent Container</h3>
    A simple & widely used approach is to wrap everything inside a &lt;div&gt;:
    <pre>
         <code class="language-jsx">
             function App() {
              return (
                &lt;div&gt;
                  &lt;h1&gt;Title&lt;/h1&gt;
                  &lt;p&gt;Paragraph&lt;/p&gt;
                &lt;/div&gt;
              );
            }
            
            export default App;
         </code>
    </pre>
    &#9989; This works because now there is only one root element (&lt;div&gt;).

    <h3>Using React Fragments (&lt;&gt;...&lt;/&gt;)</h3>
    Instead of using an unnecessary &lt;div&gt;, you can use <b><font color="blue">React Fragments</font></b>:
    <pre>
         <code class="language-jsx">
             function App() {
              return (
                &lt;&gt;
                  &lt;h1&gt;Title&lt;/h1&gt;
                  &lt;p&gt;Paragraph&lt;/p&gt;
                &lt;/&gt;
              );
            }
            
            export default App;
         </code>
    </pre>
    &#9989; Fragments are invisible wrappers. Unlike a &lt;div&gt;, they don’t add an extra node to the DOM.

    <h3>Named Fragments (&lt;React.Fragment&gt;...&lt;/React.Fragment&gt;)</h3>
    You can also use the full syntax instead of &lt;&gt;...&lt;/&gt;:
    <pre>
        <code class="language-jsx">
        function App() {
          return (
            &lt;React.Fragment&gt;
              &lt;h1&gt;Title&lt;/h1&gt;
              &lt;p&gt;Paragraph&lt;/p&gt;
            &lt;/React.Fragment&gt;
          );
        }
        
        export default App;
        </code>
    </pre>
    Normally, fragments (&lt;&gt;...&lt;/&gt;) are used to avoid unnecessary &lt;div&gt; wrappers when returning multiple 
    elements inside a component. However, there is one case where &lt;&gt;...&lt;/&gt; cannot be used: When You Need to Add a key Property (e.g., Inside Lists).
    In React, when rendering lists dynamically, each element should have a unique key to help React efficiently 
    update and re-render the UI.
    <pre>
        <code class="language-jsx">
            function App() {
                  const items = ["Item 1", "Item 2", "Item 3"];
                
                  return (
                    &lt;&gt;
                      {items.map((item, index) => (
                        &lt;React.Fragment key={index}&gt;
                          &lt;h1&gt;{item}&lt;/h1&gt;
                          &lt;p&gt;Description of {item}&lt;/p&gt;
                        &lt;/React.Fragment&gt;
                      ))}
                    &lt;/&gt;
                  );
            }    
        </code>
    </pre>
    This React function dynamically renders a list of items using JSX and &lt;React.Fragment&gt;.
    
    <h3>Summary</h3>
        
    <table style="width: 80%">
        <tr>
            <th>Approach</th>
            <th>Pros</th>
            <th>Cons</th>
        </tr>
        <tr>
            <td>&lt;div&gt;...&lt;/div&gt;</td>
            <td><span class="checkmark">✅</span> Simple & widely used</td>
            <td><span class="crossmark">❌</span> Adds unnecessary divs to the HTML</td>
        </tr>
        <tr>
            <td>&lt;&gt;...&lt;/&gt; (Fragments)</td>
            <td><span class="checkmark">✅</span> Prevents extra divs</td>
            <td><span class="crossmark">❌</span> Cannot use key prop</td>
        </tr>
        <tr>
            <td>&lt;React.Fragment&gt;...&lt;/React.Fragment&gt;</td>
            <td><span class="checkmark">✅</span> Supports key property</td>
            <td><span class="crossmark">❌</span> Slightly longer syntax</td>
        </tr>
    </table>
        
    <h2>Understanding Expressions Inside JSX:</h2>
    JSX allows you to <b><font color="blue">embed JavaScript expressions</font></b> 
    inside curly braces {} within your HTML-like code.
    <pre>
        <code class="language-jsx">
            import React from "react";

            function App() {
              const name = "Alice"; 
              return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;; 
            }
            
            export default App;
        </code>
    </pre>
    
    <h2>Understanding Attributes in JSX:</h2>
    In JSX, attributes work similarly to HTML, but some differences exist:
    <ul>
        <li>&diams; JSX uses curly braces {} to insert JavaScript expressions inside attributes.</li>
        <li>&diams; Some HTML attributes are renamed (e.g., class -> className)</li>
    </ul>
        
    <pre>
        <code class="language-jsx">
            import React from "react";
            
            function App() {
              const imgUrl = "https://i.imgur.com/NUyttbnb.jpg";
            
              return (
                &lt;div&gt;
                   &lt;h1&gt;Displaying an Image in JSX&lt;/h1&gt;
                   &lt;img src={imgUrl} alt="Example Image" width="400" /&gt;
                 &lt;/div&gt;
              );
            }
            
            export default App;
        </code>
    </pre>

    <h2>2. Components</h2>
    <p>React applications are built using components. A component is a function that returns JSX.</p>

    <h3>Basic Functional Component</h3>
    <pre><code>function Greeting() {
  return &lt;h1&gt;Hello, React!&lt;/h1&gt;;
}

export default Greeting;</code></pre>

    <h3>Using the Component</h3>
    <p>In <code>App.js</code>:</p>
    <pre><code>import Greeting from "./Greeting";
        
function App() {
  return (
    &lt;div&gt;
      &lt;Greeting /&gt;
    &lt;/div&gt;
  );
}

export default App;</code></pre>

    <h2>3. Rendering a Component</h2>
    <p>React renders components inside <code>index.js</code> using <code>ReactDOM.createRoot()</code>.</p>

    <h3>Example (<code>index.js</code>)</h3>
    <pre><code>import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(&lt;App /&gt;);</code></pre>

    <h2>4. Props (Passing Data to Components)</h2>
    <p>Props (short for properties) allow data to be passed to components.</p>

    <h3>Example:</h3>
    <pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}</code></pre>

    <h3>Passing Props to a Component:</h3>
    <pre><code>&lt;Welcome name="Alice" /&gt;</code></pre>

    <h2>5. State (Managing Component Data)</h2>
    <h3>Example using <code>useState</code>:</h3>
    <pre><code>import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;Increase&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Counter;</code></pre>

    <h2>6. Handling Events</h2>
    <h3>Example:</h3>
    <pre><code>function ClickHandler() {
  function handleClick() {
    alert("Button clicked!");
  }

  return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;
}

export default ClickHandler;</code></pre>

    <h2>7. Conditional Rendering</h2>
    <h3>Example:</h3>
    <pre><code>function Message(props) {
  return props.isLoggedIn ? &lt;h1&gt;Welcome Back!&lt;/h1&gt; : &lt;h1&gt;Please Log In&lt;/h1&gt;;
}</code></pre>

    <h2>8. Lists and Keys</h2>
    <h3>Example:</h3>
    <pre><code>const names = ["Alice", "Bob", "Charlie"];

function NameList() {
  return (
    &lt;ul&gt;
      {names.map((name, index) => (
        &lt;li key={index}&gt;{name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

    <h2>9. Forms and Input Handling</h2>
    <h3>Example:</h3>
    <pre><code>import { useState } from "react";

function Form() {
  const [text, setText] = useState("");

  function handleChange(event) {
    setText(event.target.value);
  }

  return (
    &lt;div&gt;
      &lt;input type="text" value={text} onChange={handleChange} /&gt;
      &lt;p&gt;You typed: {text}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

    <h2>10. useEffect (Handling Side Effects)</h2>
    <h3>Example:</h3>
    <pre><code>import { useState, useEffect } from "react";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Component updated! Count:", count);
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;Increase&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>

    <!-- Prism.js JavaScript -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>

    
</body>
</html>

